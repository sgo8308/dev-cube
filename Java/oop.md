# 객체지향 프로그래밍

### 객체란 무엇인가? ★

    클래스의 복제본

    세상에 존재하는 모든 유일무이한 사물
    
    클래스가 분류에 대한 개념이라면 객체는 실체라고 할 수 있다.
    
    클래스와 객체를 구분하는 방법은 생물은 나이, 사물은 제조일자를 물어보면 된다.
    
    사람은 몇살인가? 김연아는 몇살인가? 티비는 언제 제조됐는가? 이 LGTV(LM-255 모델명)은 언제 제조됐는가?
    
    사람은 클래스고 김연아는 객체다.
    
    ---
    
    김종민, 스프링 입문을 위한 자바 객체 지향의 원리와 이해, 초판 4쇄, 위키북스, 82p, 2020

### 객체 지향 프로그래밍이란 무엇인가?
    상태와 행위를 갖는 독립적인 객체들을 메시지를 통해 협력시키며 하나의 프로그램을 완성시켜 나가는 프로그래밍 방법론.
    이름 때문에 객체에 주목하기 쉽지만 객체 지향 프로그래밍에서 객체보다 중요한 것은 메시지이다.

### 어떤 배경에서 객체 지향 프로그래밍이 등장했을까?

    컴퓨터는 초창기 주로 과학실험이나 미사일 발사실험과 같은 모의 실험을 목적으로 사용되었다.
    
    이 시절의 과학자들은 모의 실험을 위해 실제 세계와 유사한 가상 세계를 컴퓨터 속에 구현하고자 노력하였으며 이러한 노력은 객체지향이론을 탄생시켰다.
    
    객체지향이론의 기본 개념은 ‘실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다’라는 것이다.
    
    실제 사물의 속성과 기능을 분석한 다음, 데이터(변수)와 함수로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상세계를 구현하고
    이 가상세계에서 모의실험을 함으로써 많은 시간과 비용을 절약할 수 있었다.


### 객체지향은 어떻게 인기가 많아졌을까?

    초기에는 절차적 언어에 밀려 객체지향 언어는 인기가 없었다.
    
    프로그램의 규모가 커지고 사용자들의 요구가 빠르게 변화해가는 상황을 절차적 언어로는 극복하기 어렵다는 한계를 느끼고  
    객체지향언어를 이용한 개발방벌론이 대안으로 떠오르게 되면서 입지를 넓혀갔다.
    
    이 후 인터넷의 발전과 함께 자바가 발표되면서 객체지향언어가 대세로 자리잡게 됐다.
    
    객체지향 이론의 탄생은 현실세계 모델링에 대한 요구로 이루어졌으나,   
    코드의 재사용성이 높고 유지보수가 용이하다는 장점이 객체지향 언어를 널리 퍼지게 만들어주었다.

### 왜 객체 지향 프로그래밍을 해야 하는가?

    좋은 코드를 짜기 위해서

    - 좋은 코드란 무엇인가?

    제대로 실행되며, 변경에 유연하고, 이해하기 쉬운 코드.

    - 제대로 실행

      기존 절차적 프로그래밍은 프로그래밍이 거대해질수록 제대로 실행되는 코드를 만들기도 어려워진다. 객체지향 프로그래밍은 프로그램을 객체 단위로 구조화 시켜줌으로써 프로그램을 작성하기 용이하게 해준다.

    - 변경에 유연

      객체 지향 프로그래밍에서 각 객체는 자신의 상태를 은닉한다.

      그 말은 한 객체가 다른 객체의 상태에 접근할 수 없다는 의미이고, 이는 객체의 상태를 변경하더라도 그 변경의 여파가 그 객체 내로 제한된다.

      또한 객체들은 메시지를 이용해서 협력하는데 그 메시지를 받은 객체가 어떤식으로 그 메시지를 처리하는지는 알지 못한다.

      따라서 한 객체가 자신이 받은 메시지를 처리하는 방식(메소드)을 바꾸었을 때 그 메시지의 인터페이스가 그대로라면, 그 메시지를 전달하는 객체는 변경에 영향 받지 않는다.

      이러한 이유들로 객체 지향 프로그래밍은 변경에 유연함을 가져다 준다.

    - 이해하기 쉬운

      연관된 변수와 메소드를 묶어 객체를 이용해 현실세계와 비슷하게 모델링할 수 있다. 이는 인간의 직관과 위배되지 않아 이해하기 쉽다.

      예를 들어 극장에서 티켓을 판매하는 프로그램이 있다고 가정할 때,

      절차적 프로그래밍은 극장이 손님의 가방을 뒤져서 돈을 가져간다면,

      객체 지향 프로그래밍은 극장이 손님에게 돈을 달라는 메세지를 보내고 메시지를 전달받은 손님은 돈을 주게된다.

      하지만 극장과 같이 무생물이 어떤 ‘행위’를 가진다는 점은 우리의 직관과 약간 위배되기는 한다.

### 객체 지향 프로그래밍의 단점은 무엇이 있을까?
    멀티쓰레드 프로그래밍이 함수형 프로그래밍에 비해 까다롭다.
        
    객체 지향 프로그래밍은 기본적으로 객체의 상태를 여러 메소드가 건드리게 된다.  
    쓰레드들이 동시에 메소드를 실행하는 과정에서 이러한 상태 변경이 문제를 야기하기 쉽다.  
    객체 지향 프로그래밍은 이러한 문제를 막기 위해서 추가적인 작업이 필요하다.  
    함수형 프로그래밍은 기본적으로 불변객체나 순수함수를 기반으로 작동하기 때문에 상대적으로 이러한 문제로부터 자유롭다.

### 자바는 객체 지향 언어라는데 어떤 특징이 있어야 객체지향 언어라고 할 수 있을까?

    객체지향언어는 기존의 프로그래밍 언어와 다른 전혀 새로운 것이 아니라,   
    기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 보다 발전된 형태의 것이다.

    어떤 언어가 추상화, 캡슐화, 상속, 다형성  등의 기능을 지원한다면
    그 지원하는 정도만큼 객체 지향 언어에 가깝다라고 할 수 있다.

### 객체 지향에는 클래스가 꼭 필요할까?

    객체 지향 언어에서는 메시지를 주고 받을 객체가 필요하다.

    객체는 클래스를 통해서 만들 수 있다.

    그러나 이름이 클래스가 아니더라도 상태와 행위를 묶을 수 있는 어떠한 것이 있다면 그것이 어떤 것이든 상관 없다.
        
    - 자바스크립트는 클래스가 없는데 어떻게 객체 지향을 구현할 수 있을까?

        프로토타입이라는 것을 통해서 구현할 수 있다.


### 객체의 null 체크가 중요한 이유는?
    
    null인 객체에 메소드를 호출하며 NullPointerException이 발생하기 때문에
    
### 런타임 다형성은 내부적으로 어떻게 구현되어 있을까?
    
    A라는 클래스를 상속한 B라는 클래스를 A 타입을 가진 변수에 할당하고,
    오버라이딩한 메소드 eat()를 호출했다고 가정하자.
    
    컴파일이 되고 난 후에는 바이트 코드에 A의 eat()를 사용한다고 나와 있다.
    
    어떻게 jvm은 이 명령을 보고 B의 eat()를 호출할 수 있을까?
    
    JVM은 클래스를 로딩할 때 이 클래스의 Class 객체를 만들고 이 클래스가 상속하고 있는 모든 클래스의 메소드가 적혀 있는 주소를 갖고 있는 vtable이란 것을 만든다.
    
    이 때 어떤 메소드가 오버라이딩 되어 있으면 부모의 메소드 이름으로도 자식의 메소드 주소가 참조되도록 vtable에 적는다.
    
    예를 들면 이런 식이다.
    
    vtable
    
    Name  Address
    
    A.eat()    211    // 자식의 메소드 주소를 가르킴
    
    B.eat()    211
    
    JVM은 invokevirtual을 호출할 때마다 어떤 주소에 있는 메소드를 호출해야하는지 vtable을 참조한다. 
    이 때 메소드의 이름을 통해서 그 메소드의 주소를 얻게 되는데 위처럼 부모 메소드의 이름이 자식 메소드의 주소를 가르키고 있으므로 자식 메소드가 실행되는 것이다.
    
     
    
    vtable이랑 엮어서 좀 더 이해 필요 
    
    ---
    
    [https://dzone.com/articles/how-does-jvm-handle-polymorphism-method-overloadin](https://dzone.com/articles/how-does-jvm-handle-polymorphism-method-overloadin)
    
    - vtable이란?
### Overriding vs Overloading
    - Overriding은 상위 클래스에 존재하는 메서드를 하위 크래스에 맞게 재정의하는 것을 의미합니다. 이 때 메서드 이름과 파라미터의 수, 리턴타입은 동일해야 합니다.
    - Overloading은 두 메서드가 같은 이름을 가지고 있으나, 파라미터 수나 자료형이 다른 경우를 Overloading이라고 합니다.
### 왜 Overriding할 때 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 못할까?
    
    자식 클래스를 조상클래스 타입 변수에 할당했다고 해보자.
    
    조상클래스에 정의된대로 public인 method를 호출했는데, 
    자식 클래스에서는 private으로 오버라이딩 되어있으면 제대로 작동하지 않을 것이다.
### overloading은 어떻게 가능한 걸까? 왜 C언어는 overloading을 하지 못할까?
    
    오버로딩은 자바의 컴파일러가 지원해주는 것이고 C언어는 컴파일러가 지원해주지 않기 때문이다.
    
    자바는 컴파일러가 심볼 테이블에 메서드 심볼을 저장할 때 메서드 이름 뿐만이 아니라 리턴 타입과 파리미터 정보까지 포함해서 저장한다. 
    반면에 C언어의 컴파일러는 단순히 메서드 이름만으로 심볼을 저장한다.
    
    따라서 C언어에서 같은 이름의 메서드가 2개 이상 있다면 링킹 과정에서 어떤 메서드를 링킹해야하는지 링커가 알 수가 없다. 
    
    ---
    
    [https://stackoverflow.com/questions/1314613/is-there-a-reason-that-c99-doesnt-support-function-overloading](https://stackoverflow.com/questions/1314613/is-there-a-reason-that-c99-doesnt-support-function-overloading)
    
    [https://www.geeksforgeeks.org/does-c-support-function-overloading/](https://www.geeksforgeeks.org/does-c-support-function-overloading/)   


### 객체 지향의 4대 특성에 대해서 설명해주세요
    - 캡슐화(Capsulation)
    - 상속(Extends)
        
        상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 추가할 수 있다는 말이다.
        
        즉 ‘확장’의 의미이지 말 그대로 ‘상속’의 의미는 아니다.
        
        이 때 ‘하위 클래스는 상위 클래스다’ 라는 말을 반드시 만족해야 상속 관계라고 할 수 있다. 
        
        예를 들면 ‘포유류는 동물이다’, ‘고래는 포유류다’는 상속 관계이지만
        ’아버지는 할아버지다’는 말이 안되므로 아버지와 할아버지는 객체 지향에서 말하는 상속 관계가 아니다.
        
        영어로 하면 is a kind of 관계를 만족해야 한다고 볼 수 있다.
        
        고래 is a kind of 동물 → 고래는 동물의 한 분류다.
        
    - 추상화
        
        추상화란 목적에 맞게 관심 있는 특성만을 추출해서 실제 사물을 단순하게 묘사하는 것이다. 
        
        자바는 이런 추상화를 class라는 키워드를 통해서 제공하는 것이다.
        
        이렇게 class라는 키워드를 통해 추상화해서 표현하는 것을 모델링이라고 한다
        
    - 다형성
        poly = 많은 morphism = 형태의 뜻을 가진 그리스어이다.
        
        즉 많은 형태라는 뜻으로, 구체적으로 하나의 메소드가 다양한 방식으로 작동하는 것을 의미한다.
        
        자바에서 다형성은 컴파일 타임 다형성과 런타임 다형성으로 나누어지는데 
        이 둘은 오버로딩과 오버라이딩으로 구현할 수 있다.
        
        ---
        
        [https://www.javatpoint.com/runtime-polymorphism-in-java](https://www.javatpoint.com/runtime-polymorphism-in-java)
        
        [https://en.wikipedia.org/wiki/Polymorphism_(computer_science)](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
        
        - 컴파일 타임 다형성과 런타임 다형성의 차이는?
            
            컴파일 타임에 어떤 메소드가 쓰일지 결정된다면 컴파일 타임 다형성이고
            
            런타임에 어떤 메소드가 쓰일지 결정된다면 런타임 다형성이다.
            
            예를 들어 A라는 클래스가 있고 eat()와 eat(String name)의 형태로 메소드가 오버로딩되어 있다고 가정하자.
            A라는 클래스를 인스턴스화 한후 eat(”h”)라는 메소드를 호출하자.
            
            이 때 컴파일을 하고 나면 바이트 코드는 정확히 eat(String name)을 호출하도록 된다.
            
            즉 컴파일 타임에 어떤 메소드가 쓰일지 결정되는 것 이다.
            
            다음은 A라는 클래스를 상속한 B라는 클래스를 A 타입을 가진 변수에 할당하고,
            오버라이딩한 메소드 eat()를 호출했다고 가정하자.
            
            컴파일이 되고 난 후에는 바이트 코드에 A의 eat()를 사용한다고 나와 있다.
            
            따라서 컴파일 이후에도 여전히 어떤 메소드가 쓰일지 결정된 상황이 아니다.
            
            런타임이 되어서야 jvm이 eat()메소드를 실행할 때 B의 eat()가 적혀 있는 주소로 가서 메소드를 실행하게 될 것이다.
            
            ---
            
            [https://www.javatpoint.com/runtime-polymorphism-in-java](https://www.javatpoint.com/runtime-polymorphism-in-java)
            
            [https://en.wikipedia.org/wiki/Polymorphism_(computer_science)](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
            
            [https://dzone.com/articles/how-does-jvm-handle-polymorphism-method-overloadin](https://dzone.com/articles/how-does-jvm-handle-polymorphism-method-overloadin)
        
    ---
    
    김종민, 스프링 입문을 위한 자바 객체 지향의 원리와 이해, 초판 4쇄, 위키북스, [, 107-117, 89, 2020


### 객체 지향의 5대 원칙(SOLID)에 대해서 설명해주세요
    - SRP(Single Resposibility Principle)
    - OCP(Open-Cloesd Principle)
    - LSP(Liskov Substitution Principle)
    - ISP(Interface Segregation Principle)
    - DIP(Dependency inversion Principle)
        
        DIP란 상위 수준의 모듈이 하위 수준의 모듈의 의존하지 않고 하위 수준의 모듈이 하쉬 수준의 모듈에 의존하게 하게해서
        고수준 모듈의 변경은 최소화하고 저수준 모듈의 변경의 유연함을 높혀주는 것을 말합니다.
        
        고수준 모듈은 상위 수준의 정책을 구현하는 클래스 또는 패키지라고 할 수 있고 
        저수준 모듈은 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능을 실제로 구현하는 클래스 또는 패키지라 할 수 있습니다.
        
        예를 들어 ‘이미지 저장’이라는 기능을 제공하는 고수준 모듈이 있습니다. 이 모듈이 저수준 모듈에 의존하고 있기 때문에 고수준 모듈의 코드에는 Astorage.save()와 같은 코드가 들어있다고 하겠습니다.
        
        만약 저장하는 저장소가 Astorage에서 Bstoreage로 바뀌게 된다면 고수준 모듈의 코드는 Astorage.save()에서 Bstorage.save()로 바뀌어야 합니다.
        
        고수준의 정책이 바뀌지 않았는데 저수준의 구현 변경으로 인해 고수준 모듈의 코드가 변경이 되는 것입니다.
        
        이 때 고수준 모듈의 관점에서 FileService라는 추상타입을 정의하고 저수준 모듈이 이 FileService라는 고수준 모듈에 의존하게 만들면 DIP를 지키게 됩니다.
        
        이 때 코드는 fileService.save()로 추상화된 형태가 될 것이고 Astorage에서 Bstorage로 바뀌어도 이 코드는 변화가 없을 것입니다.
        
        ---
        
        최범균, 객체 지향 프로그래밍 입문, 인프런, DIP파트 
        
        - 왜 고수준 모듈이 저수준 모듈에 의존하는 것이 좋지 않은 설계일까?
            
            저수준의 모듈은 자주 변경될 수 있기 때문에 이러한 설계는 좋지 않습니다.
            자주 바뀌지 않는 고수준 모듈에 저수준 모듈이 의존하는 것이 더 좋은 설계라고 할 수 있습니다. 
            
            단순하게 생각해서 한달의 고수준 모듈이 1번 변경되고 저수준 모듈이 10번 변경된다고 가정할 때, 
            고수준 모듈이 저수준 모듈에 의존하면 고수준 모듈은 총 11번 변경되고 저수준 모듈은 10번 변경될 것입니다. 
            하지만 저수준 모듈이 고수준 모듈에 의존하게 되면 고수준 모듈은 1번 변경될 것이고, 저수준 모듈은 11번 변경될 것입니다.