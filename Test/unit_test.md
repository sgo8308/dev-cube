### 단위 테스트의 목적은 무엇일까?
    
    그것은 개발 생산성을 일정하게 유지시키는 것이다.
    
    단위 테스트가 작성되지 않는다면 테스트는 수동으로 이루어져야 한다.
    
    이는 매우 시간이 많이 걸린다 때때로 실수에 의해 몇몇 테스트는 수행되지 않을 수도 있다.
    
    이는 프로그램에 버그를 유발하는 코드를 집어 넣었음에도 파악하지 못할 수 있으며 리팩토링을 두렵게 한다.
    
    결과적으로 시간이 지날수록 코드는 더러워지고 버그가 많아진다.
    
    처음에는 빠르게 개발할 수 있을지라도 나중에는 전혀 손댈 수 없는 상황에 이르게 된다.
    
    단순히 테스트를 많이 작성한다고 개발 생산성을 일정하게 유지할 수 있는 것은 아니다.
    
    나쁜 테스트 또한 같은 테스트를 아예 작성하지 않는 것만 못할 수 있다. 오히려 더 안 좋을 수도 있다. 왜냐하면 테스트를 작성하고 유지하는데 시간이 듬에도 불구하고 그 테스트들이 전혀 새로 수정된 코드에 대해 추가된 버그를 잡아낼 수 없기 때문이다.
    
    ---
    
    단위테스트 6p
    
### 단위 테스트란 무엇이고 단위 테스트의 정의에 관한 두 가지 관점은?
    
    단위 테스트란 특정한 **‘작은 부분’**만을 **‘빠르고’** **‘독립적’**으로 수행하는 것이다.
    
    여기서 1. **Unit의 크기**와 2. **독립**에 대한 두가지 관점이 있다.
    
    - 런던파
        1. **Unit의 크기**는 하나의 **클래스**라고 본다. 
        2. **독립**은 의존하는 클래스로부터의 독립을 의미한다.
            
            불변 객체를 제외한 대부분의 의존하는 객체를 test double로 대체한다.
            
    - 클래식파
        1. **Unit의 크기**는 하나의 **행동(Behaviour)**이라고 본다. 몇개의 클래스가 연관되어 있는지는 상관하지 않는다.
        2. **독립**은 각각의 단위 테스트가 서로로 부터의 독립을 의미한다.
            
            database를 공유하면 각 단위 테스트의 결과가 서로에게 영향을 미칠 수 있다. 이 때 database를 공유 의존성이라고 한다.
            
            이러한 공유 의존성을 Mocking하여 독립을 보장한다.
            
    
    여기서 ‘행동’이란 ‘강아지가 나한테 온다.’라고 할 수 있다.
    
    ‘강아지가 앞발을 든다.’, ‘강아지가 앞발을 내딧는다’ 등은 하나의 행동이라 할 수 없다.
    
### 런던파 관점과 클래식파 관점의 장점과 단점은?
    - 런던파
        - 장점
            1. 테스트가 실패하면 문제가 테스트를 하고 있는 메소드에 있다는 것을 확실히 알 수 있다. 
            2. 거대한 객체 그래프를 가진 클래스를 테스트하기 쉽다. 그렇지 않다면 직접 만들어주어야 하는데 꽤 힘들다.
            3. 한번에 하나의 클래스만 테스트할 수 있다. 그러므로 더 세밀하게 테스트 가능하다.
        - 단점
            1. 가독성 문제
                
                테스트가 각 클래스 단위로 이루어지기 때문에 비지니스 관점에서 이것이 무엇을 테스트하는 것인지 명확하지 않을 수 있다. (테스트는 프로그래머가 아닌 사람도 무엇을 테스트하는지 알 수 있어야 한다.)
                
            2. 유지보수 문제
                
                테스트가 쉽게 깨질 수 있다. 왜냐하면 Mocking을 할 때 구현 세부사항을 알아야 하기 때문이다. 다음과 같은 식이다.
                
                [Fact]
                public void Purchase_fails_when_not_enough_inventory()
                {
                	// Arrange
                	var storeMock = new Mock<IStore>();
                	storeMock
                		.Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
                		.Returns(false);
                	var customer = new Customer();
                	
                	// Act
                	bool success = customer.Purchase(
                		storeMock.Object, Product.Shampoo, 5);
                	
                	// Assert
                	Assert.False(success);
                	storeMock.Verify(
                		x => x.RemoveInventory(Product.Shampoo, 5),
                		Times.Never);
                }
                
                Mocking하는 대상에 내부 메소드를 세세하게 알아야지 테스트를 짤 수 있다. 즉 의존성이 커지는 것이다.
                
    - 클래식파
        - 장점
            1. 가독성이 좋다.
            2. 거대한 객체 그래프를 가진 클래스를 테스트하기 어렵기 때문에 이 문제 있는 코드 구조를 알아차릴 수 있다.
            3. 한 클래스에서 발생한 버그로 인해 여러 테스트가 깨진다면 이 부분이 중요한 부분이라는 힌트를 얻을 수 있다.
        - 단점
            1. 어떤 곳에서 버그가 발생했는지 찾기 어렵다. 왜냐하면 A라는 곳에서 버그가 발생하면 A를 사용하는 B의 테스트도 실패하고 연쇄적으로 실패가 일어날 수 있기 때문이다.
            하지만 코드 수정과 테스트를 자주 번갈아가면서 하면 방금 내가 마지막에 수정한 코드가 버그의 원인이라는 것을 쉽게 알 수 있어서 크게 문제가 되지는 않는다. 
            
            2. 테스트를 하는 대상의 객체 그래프가 굉장히 크다면 테스트를 준비하는데 굉장히 어려울 수 있다.
            하지만 애초에 이렇게 객체 그래프가 크게 설계하지 않는 것이 중요하고 오히려 이것이 좋지 않은 설계를 드러내줄 수 있기 때문에 좋다.
### TDD와 각각의 관점은 어떤 관계가 있을까?
    
    런던 방식은 Mock을 사용할 수 있기 때문에 outside - in 방식의 TDD를 이끈다. low level의 구현이 되어 있지 않아도 Mock으로 대체할 수 있기 때문이다.
    
    반면에 Classic 방식은 inside - out 방식의 TDD로 이끈다. Mock을 잘 사용하지 않기 때문에 가장 low level부터 개발해 나가야 한다.
    
    ---
    
    단위 테스트 36p
    
### 좋은 단위 테스트를 작성하지 않으면 어떻게 될까?
    
    테스트를 아무리 작성해도 버그가 터진다.
    
    테스트를 유지보수하는데 많은 시간이 든다.
    
    테스트가 쉽게 깨진다.
    
    ---
    
    단위 테스트 4p
    
### 단위 테스트하기 쉽게 코드를 짜는 것은 좋은 설계를 이끌어줄까?
    
    단위 테스트하기 쉽게 코드를 짜는 것은 나쁜 코드를 막아주지만 좋은 코드로 이끌어주지는 않는다.
    
    단위 테스트하기 어려운 코드는 결합도가 강하다는 의미이므로 나쁜 코드라는 신호를 보내줄 수는 있다. 하지만 결합도가 낮다고 해서 모두 좋은 코드가 되지는 않다.
    
    ---
    
    단위 테스트 5-6p
    
### 좋은 단위 테스트란?
    - 1. 회귀(기능 추가 또는 코드 수정 시 기존 기능에 생기는 버그)를 잘 잡아내야 한다.
        
        단순하고 너무 짧은 코드와 같이 회귀 문제가 생길리 없는 코드에 대해서 테스트하는 단위 테스트는 좋은 단위 테스트가 아니다.
        
        예를 들어 getter나 setter에 대한 테스트는 의미없다. 어떤 기능이 추가되거나 코드가 수정되더라도 이 메소드들에 문제가 생길리 없기 때문이다.
        
        회귀 문제는 복잡한 비즈니스 로직에서 자주 발생하므로 여기에 집중하는 테스트가 좋은 테스트다. 
        
    - 2. 리팩토링에 대한 저항성
        
        기능이 정상동작함에도 불구하고 테스트가 실패하는 것을 false positive이라고 부른다. (positive는 테스팅에서는 테스트가 실패한 경우다. 암 진단을 했다고 생각해보면 된다.)
        
        만약 false alarm(false positive)이 자주 뜨게 되면 개발자들은 점점 테스트를 무시하게 되고 종국에는 진짜 버그가 발생해도 false alarm인줄 알고 무시하게 된다.
        
        마치 양치기 소년과 같다.
        
        이런 false alarm이 거의 없는 테스트 코드가 좋은 단위 테스트다.
        
        - 어떻게 false positive을 없앨 수 있을까?
            
            테스트가 메소드에 아웃풋에만 의존하면 된다. 
            
            메소드에 구현 디테일을 전혀 몰라야 한다. 이 API를 사용하는 사용자 입장에서 테스트 코드를 작성하면 된다.
            
            구현 디테일에 의존하는 테스트 코드는 구현 방식이 바뀌면 동일하게 동작하더라도 테스트가 실패할 가능성이 크다.
            
            ex. 최악의 테스트 코드 예제
            
            [Fact]
            public void MessageRenderer_is_implemented_correctly()
            {
                string sourceCode = File.ReadAllText(@"[path]\MessageRenderer.cs");
                Assert.Equal(@"
            public class MessageRenderer : IRenderer
            {
                public IReadOnlyList<<IRenderer> SubRenderers { get; }
                public MessageRenderer()
                {
                    SubRenderers = new List<<IRenderer>
                    {
                        new HeaderRenderer(),
                        new BodyRenderer(),
                        new FooterRenderer()
                    };
                }
                public string Render(Message message) { /* ... */ }
            }", sourceCode);
            }
            
            정확히 소스 코드가 일치하는지 테스트하고 있다. MessageRenderer 클래에스 공백하나만 더 추가해도 테스트가 실패한다.
            
    - 3. 빠른 테스트
        
        테스트가 빠를 수록 테스트를 더 자주 돌려보게 되고, 버그를 도입하자마자 찾아낼 수 있다.
        
        테스트가 느릴수록 테스트를 가끔 돌리게 되고 버그가 조기에 잡을 수 없어 버그잡는데 시간이 많이 들게 된다.
        
    - 4. 유지보수성
        - 얼마나 테스트가 이해하기 쉬운지
            
            테스트가 이해하기 어려울수록 테스트를 유지보수하기 어렵다. 
            
            코드가 더 짧을수록 코드는 읽기 쉬워지고 필요할 때 바꾸기 쉽다.
            
            테스트도 당연히 바뀔 때가 있다. 메소드의 시그니쳐가 바뀌면 테스트도 바뀌어야 한다. 만약 테스트가 읽기 어려워서 수정이 어렵다면 테스트를 변경하기 싫어지고 이 테스트를 그냥 버리게 될 수도 있다. 다시 작성하는 것 또한 귀찮아서 하기 싫을 것이다.
            
        - 얼마나 테스트를 실행하기 쉬운지
            
            만약 데이터베이스와 같이 프로세스 바깥에 의존성을 갖는다면 실행시키기가 까다롭다. 데이터베이스 서버를 켜야하고 네트워크 연결을 살펴야 한다. 즉 테스트 하기가 싫어질 것이다.
            
    
    1과 2는 테스트의 정확도에 관한 것이다.  
    1은 false negative(버그가 생겼는데 테스트 통과)을 막아주고 2는 false positive(버그가 없는데 테스트 실패)를 막아준다.
    
    테스트의 가치는 이 4가지의 score를 곱하면 된다.
    
    ---
    
    단위 테스트 4장
    
### 어떻게 하면 좋은 단위 테스트를 짤 수 있을까?
    
    좋은 단위 테스트의 첫 3개의 속성은 상호 배타적이다. 따라서 적절히 트레이드 오프 해야 한다.
    
    리팩토링 저항성은 1또는 0이기 때문이다. 먼저 리팩토링 저항성을 최대한 끌어올려야 한다.  
    
    4번 속성은 첫 개와 관련이 없기 때문에 최대하 끌어올려주어야 한다.
    
    남은 2개를 잘 트레이드 오프해서 작성해야 한다.
    
    또한 테스트가 많아질수록 좋은게 아님을 명심하고 필요없는 테스트는 과감히 제거하고 최소한으로 가치있는 테스트만 유지해야 한다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d2ce3d04-91ae-47f6-82cf-5aff83c00aa4/Untitled.png)
    
    ---
    
    단위 테스트 84-86

### 테스트 네이밍은 어떻게 가져가는 것이 좋을까?
    
    일반적으로 메소드이름_테스트시나리오_반환값 등의 네이밍을 추천하는 사람들이 많다. 
    
    그러나 이 방식은 좋지 않은 방식이다.
    
    첫째로 메소드 이름이 바뀔 때마다 같이 고쳐주어야 한다.
    
    둘째로 프로그래머들만 알아먹기 쉬운 방식이다. 테스트 코드는 일종의 동작하는 문서로써  프로그래머들 뿐만이 아니라 이해관계자들이 모두 볼 수 있다. 따라서 모두가 이해할 수 있는 방식으로 써야 하며 모두가 이해하는 행동을 테스트해야 한다.
    
    따라서 특정한 틀에 맞추기 보다는 일반적인 언어로 간결하게 서술하는 것이 좋다.
    
    예를 들어 배달이 유효한지 안한지 테스트하는 메소드의 이름은 idDeliveryValid_Delivery_with_invalid_date_false()가 아니라

    Delivery_with_a_past_date_is_invalid()가 되어야 한다. 
    
    ---
    
    단위테스트 54p