### DB설계를 공부해야 하는 이유는?
    
    시행착오를 통해도 좋은 설계를 배울 수 있지만 시간이 많이 걸린다.
    
    아무렇게나 골프채를 휘두르며 골프공을 쳐도 언젠가는 좋은 샷을 때릴 수 있다.
    
    그러나 좋은 자세와 집중해야 하는 점 등을 미리 알고 진행하는 연습은 훨씬 빠르게 실력을 향상 시킨다.
    
### DB설계의 가장 중요한 기준은 무엇일까?
    1. 필수 및 임의적인 정보 검색을 모두 지원해야 한다.
    
        설계 과정에서 정의한 요구사항 뿐만 아니라 사용자에 의해 제기될 수 있는 임의의 질의를 지원하기 위해 필요한 데이터는 반드시 저장해야 한다.
    
    2. 데이터의 손실, 부정확함, 중복, 불일치, 오류와 같은 것들이 없어야 한다.
    
    3. 데이터를 쉽게 수정할 수 있어야 한다. 
        
        테이블 내의 필드값을 변경하는 것이 테이블 내의 다른 필드들의 값에 부정적인 영향을 주지 않아야 한다.
        
    4. 요구사항 변화에 의한 확장이나 수정이 쉬워야 한다.

    5. 정보 검색이 쉬워야 한다.
    
### DB설계의 단계는 어떻게 될까?
    1.  임무 명세와 임무 목표 정의
        1. 임무 명세 : 마이크의 자전거 가게 데이터베이스의 목적은 우리의 소매 사업과 고객 서비스 활동을 지원할 때 필요한 데이터를 관리하기 위함이다.
        2. 임무 목표
            1. 고객의 자동차에 대한 정보를 관리한다.
            2. 작업 지시 이력을 관리한다.
            
                  ...
            
    2. 데이터 구조 생성
        1. 테이블 정의 : 테이블이 하나의 주제만 표현하는지, 중복된 필드가 없는지 확인
        2. 필드 검토 : 다중 구성이나 다중값 필드 개선
        3. 키 설정
        4. 필드 명세 설정

    3. 테이블 관계 연결 및 결정
        1. 관계 확인
        2. 기본 키나 외래 키 연결테이블을 통해 논리적인 연결 설정
        3. 테이블에 대한 참여의 유형과 정도 결정

    4. 업무 규칙 정의 및 결정
        1. 업무 규칙 정의 : ex) 1명의 매니저는 10명의 연예인 이상 관리할 수 없다.
        2. 검증 테이블 정의 구현 : 어떤 필드에 일정 범위 내의 값들만 들어갈 수 있다면 이런 필드에 저장된 값들의 일관성과 유효성을 보장하기 위해 사용

    5. 뷰의 정의 및 결정
        1. 데이터를 어떤 식으로 처리하는지 확인
        2. 적당한 테이블과 필드를 사용하여 뷰를 정의
        3. 뷰에 대한 표준 설정

    6. 데이터 무결성 재확인
        1. 테이블 무결성 확인
        2. 필드 무결성 확인
        3. 관계 무결성 검토
        4. 업무 규칙 검토

### 새로운 기능 추가시 비용이 큰 경우와 작은 경우는 어떤 경우일까?
    - 비용이 크지 않은 경우(확장에 유연함)
        - 새로운 테이블만 추가하면 됨
        - 새로운 필드만 만들어주면 됨
        
    - 비용이 큰 경우
        - 기존 데이터를 새로운 필드로 정제해서 넣어야 함(이런 경우 기존 데이터에 대한 소급 적용이 힘들다면 기존의 데이터는 무시하는 경우도 있음)
        - 기존 필드를 없애고 새로운 필드 2개를 넣어야 함
        - 기존에 사용하던 테이블을 쪼개야 함
    
    정리해보면 기존 데이터를 건드리는 경우 비용이 크다고 할 수 있다.
    
    따라서 DB 설계시 만약 이런 기능을 추가한다면 기존 데이터에 영향이 갈까? 등을 생각하면 좋을 것 같다.
    
### 어떤 기능을 구현할 때 db에 update를 이용해서 구현하는 방식과 insert를 이용해서 구현하는 방식 중 뭐가 좋을까?
    
    update 방식은 동시성을 고려해야하는 반면
    (ex. 재고를 update쳐서 구현하는 경우 1개 남았을 때 적절하게 동시성 처리를 해주지 않으면 
    재고가 다 떨어졌는데 주문될 수 있음)에 insert는 동시성을 고려할 필요가 없다.
    
    따라서 insert 방식은 운영하기가 쉽다.
    
    하지만 update는 테이블 크기가 그대로인 반면에 insert는 테이블 크기가 커진다.
    
    동시성 문제는 처리하면 되지만 테이블 크기가 커지는 것은 어떻게 할 수 없기 때문에 update가 좋지 않을까?
### 논리적 설계를 하고 ERD를 그리는 이유는 뭘까?
    1. 팀원들과의 의사소통을 위해서
    2. 설계를 실제 테이블에 반영하거나 코드에 반영하기 위해서
### 임무 명세란?
    
    임무 명세란 일반적인 용어로 데이터베이스의 특정한 목적을 정의한 것이다.
    
    설계할 때 초점을 맞춰야 하는 부분을 알려주고 산만하고 불필요하게 크거나 복잡한 데이터베이스 구조를 만들지 않도록 해준다. 
    특정업무를 명확하게 묘사하는 문장 없이 간결하게 요점을 잘 표현해야 한다.
    
    예시
    
    1. 왓컴 주 청문회 심사관의 데이터베이스의 목적은 왓컴 주의 시민들이 제출한 토지 사용 요청서에 대한 심의를 하기 위해 심사관의 사무실에서 사용하는 데이터를 관리하기 위한 것이다.
    2. New Starz Talent Agency 데이터베이스의 목적은 생성되는 데이터베이스를 관리하고 우리가 연예인들에게 제공하는 관리 서비스와 공객에게 제공하는 계약 서비스를 지원하기 위한 정보를 공급하는 데 있다.
## 테이블
### 테이블의 대상은 어떤게 있을까?
        
    테이블의 대상은 객체가 될 수도 있고, 이벤트가 될 수도 있다. 
    
    객체일 경우 사람이나 장소 혹은 물건과 같은 유형의 사물을 의미한다.
    
    이벤트일 경우 테이블이 기록하고자 하는 특성들을 특정 시간대에 발생하는 것들을 표시하는 것을 의미한다.
        
### 테이블은 어떻게 나누어야 할까?
    임무 목표, 예비 필드 목록 등을 이용해 나눈다.

### 이상적인 테이블의 요소는 어떤게 있을까?
    - 개체 또는 사건일 수 있는 단일 주제를 나타낸다.
    
    각 테이블이 단일 주제를 나타내는 한 중복되는 데이터를 줄일 수 있기 때문에 잠재적인 데이터 무결성 문제의 위험이 크게 줄어든다.
    
    ---
    
    [https://support.microsoft.com/en-us/office/database-design-basics-eb2159cf-1e30-401a-8084-bd4f9c9ca1f5#bmgood](https://support.microsoft.com/en-us/office/database-design-basics-eb2159cf-1e30-401a-8084-bd4f9c9ca1f5#bmgood)
    
    - 기본 키를 가진다.
    
    레코드들을 유일하게 식별하고 테이블의 관계를 설정을 위해 필요하다.
    
    기본 키가 없어도 무결성 문제가 생길 수 있다.
    
## 필드
### 이상적인 필드의 요소는 어떤게 있을까?
    - 테이블 주제의 고유한 특성을 나타낸다.

    - 오직 하나의 값만 포함한다. (다중 값 필드 안된다.)
        - 다중 값 필드는 데이터 중복 문제를 일으킨다.
        - 안에 데이터를 수정, 삭제, 정렬, 그룹화하려고 할 때 사용하기 힘들다.

    - 더 작은 구성요소로 해체될 수 없다. (다중 구성 필드 안된다)
        - 다중값 필드처럼 이 안의 데이터를 수정, 삭제, 정렬, 그룹화하려고 할 때 문제를 일으킨다.
            
            Address
            3131 Mockingbird Lane Seattle, WA 98157 
            
            위와 같은 필드는 시애틀 시를 위한 정보를 검색하거나 우편번호로 정보를 정렬하는 데 어려움을 겪는다.
            
    - 계산되거나 연결된 값을 포함하지 않는다. 
        ex ) name은 first name 과 last name을합친 필드다.
            - 계산된 필드는 다른 칼럼에 의존한다. 다른 칼럼이 수정되었을 때 이 칼럼도 수정되어야 하는데 이 수정이 함께 진행되지 않아 데이터 정합성에 어긋나기 쉽다.

    - 전체 데이터베이스 구조 안에서 유일한다.
        - 유일한 이중 필드는 테이블의 관계를 설정하는 필드여야 한다. 이 것 이외에 이중 필드가 나타나면 일관성이 없게 될 것이 틀림없다.  ex)한쪽은 10인데 한쪽은 20을 갖고 있는

    - 하나 이상의 테이블에 나타날 때는 속성들의 대부분을 유지한다. ??
### 좋지 않은 필드는 어떤 필드일까?
    1. 계산된 필드
    2. 다중 구성 필드
    3. 다중값 필드
    
    Id First Name Last Name    Full Name     (City, State, Zip) Account Rep
    1   Stewart    Jameson  Stewart Jameson  Seattle, WA 98125  John, Sandi
    
    Full Name → 계산된 필드
    
    City, State, Zip → 다중 구성 필드
    
    Account Rep → 다중 값필드
    
### null값은 왜 안좋을까?
    1. null값은 오해를 불러일으키기 때문에 안 좋다.
        
        null 값은 다음과 같이 해석될 수 있다.
        
        1. 값이 아무 것도 없다.
        2. 값이 아직 입력되지 않았다.
        3. 에러가 발생해서 값이 누락되었다. 등등
        
        이와 같이 어떤 레코드에 null 값이 있을 때 이 값이 무엇을 의미하는지 명확하지가 않기 때문에 피하는 것이 좋다.
        
    
    2. null이 포함된 연산은 그 결과가 null로 나오기 대문에 수학적 연산에 안 좋다.
    
    ---
    
    [https://stackoverflow.com/questions/163434/are-nulls-in-a-relational-database-okay#:~:text=Nulls are negatively viewed from,items which have no value](https://stackoverflow.com/questions/163434/are-nulls-in-a-relational-database-okay#:~:text=Nulls%20are%20negatively%20viewed%20from,items%20which%20have%20no%20value).
    
    마이클 J. 헤르난데즈, 파워 오브 데이터베이스, 비제이퍼블릭, 초반 1쇄, 33-34, 2019
    
### null값은 언제 허용해줄까?
    
    성능 이슈 때문에 나누어진 테이블을 다시 합치는게 불가피할 때(Join 횟수를 줄이기 위해) 생겨나는 null값은 어쩔 수 없다.
    
    ---
    
    [https://stackoverflow.com/questions/163434/are-nulls-in-a-relational-database-okay#:~:text=Nulls are negatively viewed from,items which have no value](https://stackoverflow.com/questions/163434/are-nulls-in-a-relational-database-okay#:~:text=Nulls%20are%20negatively%20viewed%20from,items%20which%20have%20no%20value).
    
### 필드의 데이터 타입과 길이를 적절하게 선택해야 하는 이유는 뭘까?
    
    만약 칼럼의 타입이 잘못 선정되거나 길이가 너무 부족하면 서비스 도중에 스키마 변경이 필요할 수도 있다. 그런데 스키마 변경 작업은 서비스 중지나 읽기 전용 모드(스키마 변경하는 동안 INSERT, UPDATE, DELETE 불가)로의 전환 작업이 필요할 수도 있다. 이는 서비스의 가용성을 훼손하기 때문에 최적의 타입과 길이를 선정하는 것이 중요하다.
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0 2권, 2쇄, 위키북스, 356p, 2022
### 언제 ENUM을 쓰고 언제 참조 테이블을 쓸까?
    
    기본적으로는 ENUM을 쓰는게 테이블 수도 줄이고 Join도 필요 없어서 성능에 약간 좋다. 따라서 ENUM을 쓰지 않아야 할 상황을 제외하면 ENUM을 쓰는게 좋을 것 같다.
    
    ENUM의 장점 
    
    1. 쿼리가 참조 테이블을 쓸 때에 비하여 간단하다.
    2. 쿼리에서 id가 아닌 ENUM 값을 그대로 집어 넣을 수 있어 명확하다.
        
        ex) color = 1이 아닌 color = 'Red'
        
        하지만 다음과 같이 쓸 수 있긴 하지만 복잡해진다.
        
        INSERT INTO 'main_table' ('field_1', 'field_2', 'color_id')
        VALUES (
        'foo', 
        'bar', 
        (SELECT color.color_id FROM color WHERE color.color_name = 'red')
        )
        
    3. 성능이 약간 더 좋다. 
    
    ENUM의 단점
    
    1. ENUM 칼럼은 속성을 추가하거나 연관된 정보를 저장할 수 없지만 참조 테이블은 가능하다.
    2. ENUM 칼럼에 정의된 값들은 다른 테이블에서 재사용할 수 없다.
    3. ENUM 모든 데이터 목록을 조회하는 것이 힘들다.
        
        코드 상에서 ENUM 목록을 표현할 경우 ENUM 값을 수정할 때마다 코드와 DB 테이블 두군데를 수정해야 하고 재컴파일 재배포가 필요하다.
        
    4. ENUM의 들어있는 값을 수정하거나 추가하려면 테이블을 ALTER 해야 하고 테이블이 거대할 경우 비용이 많이 든다.(시간)
    
    ---
    
    [http://komlenic.com/244/8-reasons-why-mysqls-enum-data-type-is-evil/](http://komlenic.com/244/8-reasons-why-mysqls-enum-data-type-is-evil/)
    
### DATETIME vs TIMESTAMP
    1. TIMESTAMP는 범위가 
    
    '1970-01-01 00:00:01.000000' to'2038-01-19 03:14:07.999999'
    
    이기 때문에 2038년 이후에는 데이터를 저장하고 싶지 않은게 아니라면 DATETIME을 써야할 것 같다. 

### 문자열 데이터 타입에서 뒤에 숫자 값은 무엇을 의미할까?
    
    뒤에 숫자 값은 바이트 수가 아니라 넣을 수 있는 문자의 수를 의미한다.
    
    따라서 같은 CHAR(10)이라도 실제 디스크나 메모리에서 사용하는 공간은 달라진다.
    
    영어를 포함한 서구권 언어는 각 문자가 1바이트이므로 10바이트
    
    한국어나 일본어와 같은 아시아권 언어는 각 문자가 최대 2바이트를 사용하므로 20바이트를 사용한다.
    
    UTF-8과 같은 유니코드는 최대 4바이트까지 사용하므로 40바이트까지 사용할 수 있다.
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0 2권, 2쇄, 위키북스, 359p, 2022
    
### CHAR vs VARCHAR
    
    둘의 가장 큰 차이는 CHAR는 고정 길이이고 VARCHAR는 가변 길이라는 것이다.
    
    이 특징을 바탕으로 두 데이터 타입을 선택할 때 다음 2가지가 중요한 기준이 된다.
    
    ‘저장되는 문자열의 길이가 대개 비슷한가?’
    
    ‘칼럼의 값이 자주 변경되는가?
    
    문자열의 길이가 전혀 비슷하지 않다면 CHAR 타입은 가능한 최대의 길이를 설정해야 하기 때문에 공간의 낭비가 심해질 수 있다.
    
    한 편 칼럼의 값이 더 크게 변경될 경우 VARCHAR 타입은 실제 저장되어 있는 공간에서 다시 다른 공간으로 옮겨 저장해야하므로 시간이 더 걸린다. 
    
    - 칼럼의 값이 더 크게 변경될 경우 VARCHAR 타입이 다른 공간으로 옮겨 저장해야 하는 이유는?
        
        데이터는 VARCHAR 하나만 저장되는 것이 아니라 다른 칼럼의 데이터도 같이 저장된다. 그렇기 때문에 A B C 칼럼이 있고 B가 VARCHAR이고 abcde라는 값이 저장되어 있을 경우 내부적으로 디스크는 다음과 같이 저장된다.
        
          A                   B                   C
        
        [?] [?] [?] [?] [a] [b] [c] [d] [e] [?] [?] [?]
        
        양 옆이 다른 데이터로 이미 채워져 있기 때문에 쉽게 더 길이가 긴 데이터를 채워 넣을 수가 없다.
        
        반면에 CHAR는 이미 공간을 확보해놓기 때문에 길이가 더 긴 데이터를 쉽게 넣는 것이 가능하다.
        
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0 2권, 2쇄, 위키북스, 358-359, 2022

### VARCHAR vs TEXT
    
    VARCHAR와 TEXT는 둘 다 65535바이트까지 저장할 수 있다.
    
    하지만 MySQL은 기본적으로 한 레코드 당 65535바이트 이상 저장할 수 없기 때문에 VARCHAR는 다른 칼럼이 이미 40kb를 차지했따면 24kb정도만 차지할 수 있다. 이 때 24kb가 넘는 데이터를 추가하려고 하면 에러가 발생하거나 VARCHAR 타입이 TEXT 타입으로 자동 변환된다.
    
    반면에 TEXT 데이터 타입은 레코드 최대 저장 공간을 초과할 경우 다른 곳에 저장을 따로 하기 때문에 65535바이트를 저장할 수 있다.
    
    따라서 적당히 큰 데이터라면 TEXT를 사용하는 것이 낫다. 
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0 2권, 2쇄, 위키북스, 356-357, 2022
### 1~2GB 정도의 데이터 크기를 줄이는 것이 얼마나 효과가 있을까?
    - 메모리 효율성
        
        디스크의 데이터는 InnoDB 버퍼 풀로 적재돼야 쿼리에서 비로소 사용할 수 있다.
        
        즉 디스크의 데이터가 크다는 것은 메모리도 그만큼 많이 필요해진다는 이야기다.
        
    - 백업 또는 복구 시간 감소
        
        당장 장애가 발생했는데, 백업 파일을 복사하는데 3~4시간이 걸린다면 이 시간 동안은 서비스가 불가능해진다. 
        
    - 스키마 변경 및 인덱스 생성 시간 감소
    
    ---
    
     백은빈, 이성욱, Real MySQL 8.0 2권, 2쇄, 위키북스, 400p, 2022   

### 왜 모든 테이블에 생성 시각과 최근 업데이트 시각 필드를 포함하는게 좋을까?
    1. 시간을 이용해서 디버깅 하기가 용이하다.
    2. 향후 데이터 아카이브를 구현할 수 있다. (?)
    3. 중요한 회계 정보를 제공할 수 있다.(?)
    
    ---
    
    [https://blog.dionbeetson.com/2014/06/why-every-database-table-should-have.html](https://blog.dionbeetson.com/2014/06/why-every-database-table-should-have.html)
## 키
### 자연키 vs 인조키
    - 자연키

        - 장점
            
            MySQL의 InnoDB스토리지 엔진의 경우 기본키를 바탕으로 테이블 자체가 클러스터링 인덱스가 되기 때문에 자연키를 기본키로 한다면 이 자연키를 위해 따로 인덱스를 구성할 필요가 없다. 
            
            클러스터링 인덱스가 될 경우 기본키를 기준으로 범위 검색 시 매우 빠르다.
            
            커버링 인덱스가 작용할 가능성이 높다.
            
            인조키를 위한 추가 공간이 필요하지 않다.
            
        - 단점
            
            비즈니스 요구사항에 의해서 기본키로 사용하던 자연키에 변화가 생기면 문제가 생길 수 있다. 예를 들어 직원 목록에 주민번호를 기본키로 사용했는데 주민번호가 없는 외국인 직원이 생기면 난감하다.
            
            삽입 삭제 시 테이블을 자연키에 맞춰 다시 정렬해줘야 하기 때문에 느리다.
            
    - 인조키

        - 장점
            
            비즈니스 요구사항 변화에 영향 받지 않는다.
            
            삽입시 추가된 데이터의 인조키 값이 항상 다른 데이터보다 크기 때문에 따로 정렬이 필요 없어서 빠르다. 삭제할 경우에도 따로 정렬해줄 필요가 없다.
            
### 인조키를 사용할 때 만약 Product 테이블이라면 기본키의 이름을 id로 할까 product_id로 할까?
    - id로 할 때
        - 장점
            - 쿼리날릴 때 중복이 없어진다.
                
                ex ) 
                
                SELECT * FROM Product WHERE Product.id = 10, 
                
                SELECT * FROM Product WHERE Product.Product_id = 10,   
                
        - 단점
            - 외래키로 사용되는 테이블도 id를 갖고 있기 때문에 외래키로 사용될 때 이름이 바뀌어야 한다. 따라서 이 외래키가 정말 기본 키를 참조하는지 헷갈릴 수 있다.
    - product_id로 할 때는 장단점이 반대이다.
    
    항상 id가 외래키로 변할 때 테이블이름_id 형태로 일관성 있게 가져간다면 헷갈릴 여지가 없기 때문에 좀 더 깔끔한 id를 쓰는게 나을 것 같다.
        
### 다른 곳에서 참조되고 있는 기본키를 가진 레코드를 삭제하거나 기본키 값을 수정할 수 있을까?
    
    없다.
    
    이 테이블에 기본키를 외래키로 갖고 있는 다른 테이블들에서 이 외래키가 삭제되거나 수정될 때 어떤 식으로 처리할지 외래키 제약 조건으로 정해놓지 않으면 불가능하다.
    
    다음과 같은 옵션을 정해놓아야 한다. 
    
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
    
    ---
    
    [https://papimon.tistory.com/90](https://papimon.tistory.com/90)
    
    [https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html](https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html) - Referential Actions 파트
    
### 기본키와 not null + unique의 차이는?
    
    기본키는 한 개 밖에 존재할 수 없다.
    
    기본키는 클러스터링 인덱스에 사용될 수 있다.
## 관계
### 다대다 관계가 좋지 않은 이유는 뭘까?
    
    다대다 관계를 가진 테이블을 설계하다 보면 필연적으로 좋지 않은 필드 구조를 갖게 되기 때문이다.
    
    그렇게 되면
    
    1. 테이블 중 하나에는 대량의 중복 데이터가 포함될 것이다.
    2. 데이터를 삽입 / 갱신 / 삭제 하기가 어려울 것이다.
### 부모 테이블과 자식 테이블은 어떻게 정할까?
    
    자식 테이블에 있는 레코드는 반드시 부모 테이블과 관련이 있어야 한다는 관점으로 접근한다.
    
    예를 들어 직원 테이블과 보상 테이블이 있을 때 보상 테이블(어떤 직원이 얼마를 받는지)을 자식 테이블로 정하는 것이 합리적인데, 
    왜냐하면 직원과 관련이 없는 보상 테이블은 말이 안되기 때문이다. 
    
    부모 테이블은 꼭 자식과 관련될 필요가 없을 수도 있기 때문에, 부모 테이블로 삼아야 할 것을 자식 테이블을 삼으면 외래키에 null값이 많이 생길 것이다.
    
    ---
    
    마이클 J. 헤르난데즈, 파워 오브 데이터베이스, 비제이퍼블릭, 초반 1쇄, 254p , 2019
### 식별관계 vs 비식별관계
    
    식별관계는 부모테이블의 기본키를 자식 테이블이 자신의 기본키로 사용하는 관계이고 비식별관계는 식별관계가 아닌 관계이다.
    
    * 식별관계의 장점
    
    1. 식별관계는 기본 키 인덱스를 활용하기 좋다. 부모키를 조건으로 검색하는 경우에 따로 부모키 인덱스를 구성할 필요없이 기본키 인덱스를 활용하면 된다.
    2. 상위 테이블들의 기본 키 칼럼을 자식, 손자 테이블들이 가지고 있으므로 특정 상황에 조인 없이 하위 테이블만으로 검색을 완료할 수 있다.
    - 복합키를 구성해서 자동차가 타이어를 4개 이상 갖지 못하도록 제약하여 무결성에 도움을 줄 수 있다 판단했는데 그것은 비식별관계에서도 유니크 제약조건을 두 칼럼에 거는 것으로도 가능하기 때문에 제외했다.
    
    * 식별관계의 단점
    
    1. 일대다 관계의 경우 복합키를 만들어야 한다.
    2. 테이블의 구조가 유연하지 못하다.
        
        항상 부모 테이블에 데이터가 먼저  존재해야 하기 때문에 자식 테이블에 데이터가 먼저 생성이 가능하도록 비즈니스 요구사항이 변경된다면 대응하기가 힘들다. 
        
    
    식별관계의 단점이 장점보다 크기 때문에 보통은 비식별관계를 주로 쓴다.
    
    상속 관계는 일종의 일대일 관계이자 식별관계인 경우인데, 상속 관계 같은 경우 사실 두 테이블이 하나의 레코드를 쪼개놓은 형태이기 때문에 자식테이블의 데이터가 먼저 생성되야 한다는 요구사항이 생기기 어려워 딱히 식별관계를 써도 단점이 없는 것 같다.
    
    따라서 일반적으로는 비식별 관계를 사용하고 상속 관계나 다른 특수한 경우에 식별관계를 사용한다.
    
    ---
    
    김영한, 자바 ORM 표준 JPA 프로그래밍, 에이콘출판, 7.3.6절,2015

### 업무 규칙이란?
    
    데이터베이스에 비즈니스에 특성에 따라 제약을 부과하는 문장.
    
    예를 들어 ‘어떤 주어진 주문을위해서 ‘배송 일자’는 ‘주문일자’보다 더 이전일 수는 없다.
    
    이 업무 규칙은 배송 일자 필드를 위한 필드 명세의 값 범위요소에 제약조건을 부과한다.

## 뷰
### 공부해야 하는 이유는?
    
    필요할 때 사용할 수 있기 위해서
    
### 정의는?
    
    하나 또는 여러 테이블을 이용해 만드는 가상의 테이블이다. 여러 테이블에서 칼럼을 그대로 가지고 오거나 계산해서 가지고 올 수 있다.
    
    stored query의 결과 집합이라고도 하며 테이블에 접근하듯이 접근하지만 접근할 때마다 stored query를 이용해 새로 구성된다.
    
    ---
    
    [https://en.wikipedia.org/wiki/View_(SQL)](https://en.wikipedia.org/wiki/View_(SQL))
    
### 사용해야 하는 이유는?
    1. 뷰를 통해 기본 테이블에 노출하고 싶은 부분만 노출하고 기본 테이블로의 접근을 차단함으로써 보안을 향상시킬 수 있다.
        (보안 상 중요한 부분을 못보게 하면서 같은 테이블에 있는 보여줄 필요가 있는 부분은 노출 가능)
    2. 복잡한 쿼리가 간단해질 수 있고 가독성이 향상된다.
    3. 뷰를 OOP에서 인터페이스라고 생각하고 기본 테이블들을 구현체라고 생각하면 뷰를 통해 추상화가 되면서 
        뷰를 사용하는 쿼리가 존재하는 코드가 기본 테이블에 변경사항에  영향을 받지 않게 된다.
    
    ---
    
    [https://en.wikipedia.org/wiki/View_(SQL)](https://en.wikipedia.org/wiki/View_(SQL))

### 실무에서도 뷰를 잘 사용할까?
    
    필요한 경우에 사용하는 경우도 있지만 대부분 뷰의 역할을 위해 따로 조회용 DB를 사용하거나 캐시를 대서 어플레케이션에서 활용하는 듯하다.
    
    ---
    
    Derek 멘토님

## 정규화
### 

### 어느정도까지 공부해야 할까?
    
    정규화를 이해하고 DB설계시 정규화를 할 수 있는정도
    
### 정의는?
    
    이상 현상이 발생되지 않도록 하기 위해 데이터를 구조화하는 프로세스
    
    이상 현상은 테이블이 관련 없는 속성들로 구성되었을 때 발생한다. 
    따라서 테이블을 관련 있는 속성들로만 구성하기 위해 테이블을 분해하는 것을 정규화라할 수 있다. 
    
    6차 정규형까지 존재하나 보통은 3차 정규형과 BCNF까지 정규화를 진행한다.
    
    ---
    
    [네이버 지식백과](https://terms.naver.com/entry.naver?docId=3431245&cid=58430&categoryId=58430&expCategoryId=58430)
    
    [https://www.guru99.com/database-normalization.html#1](https://www.guru99.com/database-normalization.html#1)
    
### 사용해야 하는 이유는?
    1. 삽입, 삭제, 수정에서 발생하는 이상현상을 없앨 수 있다.
    2. 중복을 최소화하여 저장 공간을 아껴준다.
    3. 새로운 타입에 데이터가 들어왔을 대 관계들을 재구성해야 할 필요를 줄여주어 애플리케이션의 생명을 증가시키기 위해 ?
    
    ---
    
    [https://www.guru99.com/database-normalization.html#1](https://www.guru99.com/database-normalization.html#1)
    
    [https://en.wikipedia.org/wiki/Database_normalization#Normal_forms](https://en.wikipedia.org/wiki/Database_normalization#Normal_forms)
    
### 어떤 방식으로 진행할까?
    
    테이블에 칼럼들이 기본키 외에 함수적 종속성을 갖지 않도록 점진적으로 테이블을 만들어 간다.
    
    ---
    
    [https://terms.naver.com/entry.naver?docId=3431245&cid=58430&categoryId=58430&expCategoryId=58430](https://terms.naver.com/entry.naver?docId=3431245&cid=58430&categoryId=58430&expCategoryId=58430)
    
### 정규형의 종류는?
    - 기본 정규형
        - 제 1 정규형
            
            테이블의 속성은 다중값을 가지면 안되고 원자값만 가지면 제1정규형에 속한다.
            
            이 정규형은 이상 현상을 없애주지는 못하지만 다음 정규형에 기초가 된다.
            
            다중값을 막는 것은 여러 장점이 있다.
            
        - 제 2 정규형
            
            테이블이 제 1정규형에 속하고 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제2정규형에 속한다.
            
            제 2 정규형으로 만드는 과정에서 테이블이 분해된다. 
            
            하지만 제 2 정규형을 만족하더라도 하나의테이블에 함수 종속 관계가 여러 개 존재하고, 논리적으로 이행적 함수 종속 관계가 유도되면 이상 현상이 발생할 수 있다.
            
        - 제 3 정규형
            
            테이블이 제2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제3정규형에 속한다.
            
            보이스/코드 정규형과 마찬가지로 제3정규형을 위반하는 모든 테이블에 이상현상이 생기는 것은 아니다.

            한 편 어떤 속성이 기본키에 이행적으로 종속된다고 하더라도 그 속성이 기본키에 직접적으로도 종속된다면 제 3정규형을 위반한다고 볼 수 없을 것 같다.

            예를 들어 

            고객 아이디   등급   할인율
            sg9939      gold    10%

            와 같은 테이블이 있을 경우 

            고객 아이디 → 등급

            등급 → 할인율

            이면서 고객 아이디에 할인율이 직접적으로 의존하지는 않기에 제 3정규형을 위반했다고 볼 수 있다.

            하지만 다음과 같은 경우

            결제번호  전체금액  할인금액  최종금액
            100123  10000    1000     9000

            결제번호 → (전체금액, 할인금액)

            (전체금액,할인금액) → 최종금액

            이지만 결제번호에 최종금액이 직접적으로 의존하고 있다고 볼 수도 있으므로 이 경우는 제 3정규형을 위반했다고 불 수 없다. 

            후보키를 하나만 가지고 있는 테이블에서 이 정규형은 이상 현상을 없앨 수 있다.
            
        - 보이스/코드 정규형
            
            릴레이션의관계에서 모든 결정자가후보키이면 보이스/코드 정규형에 속한다.
            
            이 경우 결정자와 종속자가 다음과 같은 경우

            결정자 : 등급 종속자 : 할인율 

            보이스/코드 정규형에 속하지 않으면 이상 현상이 생길수 있다.

            왜냐하면 다음과 같은 테이블에서

            고객아이디  등급  할인율
            sgfw2222    gold  10%
            shwff       gold  10%

            등급의 이름이 gold에서 grand로 바뀌면 모든 중복되는 gold를 다 grand로 바꾸어줘야 하는데 부분적으로만 바뀌는 실수를 할 수 있기 때문이다.

            한 편 다음과 같은 테이블에서 두 레코드는 (전체 금액, 할인 금액)이 같다.

            결정자 : (전체 금액, 할인 금액) 종속자 : 최종금액

            결제번호  전체금액  할인금액  최종금액
            1237172   10000     1000      9000
            1343433   10000     1000      9000

            그러나 첫번째 레코드에 (전체금액,할인금액)이 (10000,1000)에서 (10000,3000)원으로 변한다고 해서
            두번째 레코드에 (전체금액,할인금액)이 또한 변경해주어야 하는 것이 아니기 때문에 수정 이상현상이 생기지 않는다. 
            비슷한 식으로 이 경우는 갱신 이상, 삭제 이상도 생기지 않는다.

            따라서 보이스/코드 정규형이 지켜지지 않는 모든 테이블에 이상 현상이 생기는 것은 아니다.

            하지만 이 정규형을 통해 대부분의 이상 현상을 없앨 수 있다.
                
        - 고급 정규형
            - 제 4 정규형
            - 제 5 정규형
    
        ---
    
        [https://terms.naver.com/entry.naver?docId=3431252&cid=58430&categoryId=58430&expCategoryId=58430](https://terms.naver.com/entry.naver?docId=3431252&cid=58430&categoryId=58430&expCategoryId=58430)
    
### 이상현상이란?
    - 수정 이상(Update anomaly)
        
        데이터들이 중복이 있을 때 하나의 데이터에 수정된 사항은 중복되는 모든 데이터도 동일하게 변경되어야 한다. 이 때 모두 변경되지 않아 같은 것을 표현해야 하는 데이터가 서로 다른 것을 표현하고 있을 때 수정 이상이라고 한다.
        
        예를 들어 A라는 사람의 키가 180 이라는 데이터가 3군데 존재할 때 키가 190으로 변하였다면 이 3군데 데이터를 모두 변경해주어야 한다. 이 때 딱 한군데만 190으로 변경된다면 이 테이블에는 A의 키가 180이라는 데 이터와 190이라는 데이터가 동시에 존재하게 되므로 무엇이 진실인지 알 수 없어진다.
        
    - 삽입 이상(Insertion anomaly)
        
        어떤 테이블에 데이터를 집어 넣기 위해서 원치 않는 불필요한 데이터도 함께 삽입해야 하는 문제는 삽입 이상이라고 한다. 
        
        ---
        
        [네이버 지식백과](https://terms.naver.com/entry.naver?docId=3431242&cid=58430&categoryId=58430)
        
    - 삭제 이상(Deletion anomaly)
        
        어떤 테이블에서 레코드를 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 현상.
        
        [네이버 지식백과](https://terms.naver.com/entry.naver?docId=3431244&cid=58430&categoryId=58430)
        
### 함수적 종속성이란?
    f(x) = y의 관계라고 생각하면 쉽다. X에 무엇을 넣느냐에 따라 Y가 결정된다.

    테이블에 X라는 속성이 무엇이냐에 따라서 Y라는 속성이 결정될 때 Y라는 속성은 X라는 속성에 함수적으로 종속되어 있다고 한다.

    이 때 X라는 속성을 결정자 Y라는 송석을 종속자라고 하는데 결정자는 여러 속성들의 집합이 될 수 있다. ( f(x1,x2) = y라고 할 수 있다.)

    ---

    [네이버 지식백과](https://terms.naver.com/entry.naver?docId=3431246&cid=58430&categoryId=58430&expCategoryId=58430)

### 완전함수 종속 부분함수 종속이란?
    
    f(x1,x2) = y의 관계일 때 f(x1) = y의 관계 또한 만족하면 부분함수 종속이라고 한다. 
    
### 이행적 함수 종속이란?
    
    칼럼이 X Y Z가 있다고 하자.
    
    1. X에 의해서 Y가 결정된다.
    2. Y에 의해서 X가 결정되지 않는다.
    3. Y에 의해서 Z가 결정된다.
    
    이 상황일 때 Z는 X에 이행적으로 함수 종속된다고 한다.
    
    2번 속성이 중요한데 안 그러면 다음과 같은 테이블은 제 3정규형을 만족하지 않게 된다.
    
    id    userid    password
    1     sg993     dfjisdfj
    2     ggio93    hotototo
    
    왜냐하면 id가 password를 결정하고 userid도 password를 결정하기 때문이다.
    
    2번 조건을 통해 userid가 id를 결정하는 이 테이블은 제 3정규형을 만족한다.
    
    ---
    
    [https://en.wikipedia.org/wiki/Transitive_dependency](https://en.wikipedia.org/wiki/Transitive_dependency)