# 회원가입 / 로그인
## 인증 / 인가
### 인증이란?
    
    인증이란 사용자가 등록된 사용자인지를 확인하는 것이며, 사용자가 보낸 메시지가 변조되지 않은 그대로의 것인지를 확인하는 것이다.
    
    첫번째 작업은 아이디와 패스워드를 가입 목록에서 대조하는 방식을 사용하고 두번째 작업은 메시지 인증 부호, 디지털 서명 부호 등이 사용된다.
    
    ---
    
    [https://terms.naver.com/entry.naver?docId=855723&cid=42346&categoryId=42346]
    
### 인가란?
    
    사용자가 특정한 서비스를 사용할 수 있는 권한이 있는지 확인하는 절차. 예를 들어 어떤 글을 수정한다거나 관리자 페이지에 들어간다거나 하는 것 들이 모두 권한이 필요하다. 이러한 일들을 할려면 서버로부터 인가를 받아야 한다.
    
    ---
    
    [https://terms.naver.com/entry.naver?docId=849375&cid=50371&categoryId=50371]
## 패스워드 암호화
### 패스워드는 왜 DB에 암호화해서 저장해야할까?

      패스워드는 사용자 인증할 때 말고는 사용되지 않는다.

      이 인증은 복호화가 불가능한 암호화 방식을 사용하더라도 구현할 수 있다.

      이렇게 해두면 해커한테 DB가 털리더라도 암호화된 패스워드는 해독이 불가능하기 때문에 안전하다.

      여러 웹사이트에서 비밀번호 찾기를 했을 때 그대로 비밀번호를 알려주는게 아니라 새 비밀번호로 바꾸도록하는 이유는 비밀번호가 암호화되어 있기 때문이다.

      또한 법으로도 암호화하도록 정해져 있다.

### 단순 해시 함수로는 복호화가 불가능하더라도 비밀번호가 안전하지 않다 왜그럴까?

      왜냐하면 해커는 다이제스트를 얻어 브루트포스 공격을 통해 원문을 알아낼 수 있기 때문이다.

      브루트포스 공격은 영문 + 숫자 조합 같이 패스워드로 그럴듯한 값들을 무차별적으로 해시 함수에 대입하여 탈취된 다이제스트와 동일한 값을 갖는지 비교하여 원문을 알아내는 방법이다.

      해시 함수가 아무리 빠르더라도 이 작업에는 시간이 많이 걸린다. 따라서 레인보우 테이블이라는 것을 같이 사용하는데 이것은 그럴듯한 비밀번호와 그것의 다이제스트가 무수히 많이 저장되어 있는 테이블이다.

      이 테이블과 탈취한 다이제스트를 이용하여 브루트포스 공격을 더 빠르게 성공시킬 수 있다.

### 단순 해시 함수를 보완하는 방법은 무엇이 있을까?
    - 키 스트레칭(key stretch) 방법

      패스워드를 해싱 함수를 통하여 다이제스트를 얻어낸다.

      이 다이제스트를 해싱 함수를 통하여 새로운 다이제스트를 얻어낸다.

      이런 식으로 여러 번 반복해서 최종 다이제스트를 얻어서 저장하는 방법이다.

      이 방법의 장점은 원문으로부터 최종 다이제스트를 얻기까지 걸리는 시간을 늘리는데 있다.

      해커가 단순 해시 함수를 통해 1초에 50억번 대입해볼 수 있었다면, 키 스트레칭이 적용된 다이제스트를 사용하면 1초에 5번밖에 대입하지 못하게 만들 수 있다.

    - 솔트(salt) 알고리즘

      패스워드에다가 임의적인 값을 덧붙힌 후 해시 함수를 적용하는 방법이다.

      솔트가 붙은 비밀번호는 일반적인 비밀번호와 완전히 달라지기 때문에 브루트포스 공격으로 뚫기가 쉽지 않으며 레인보우 테이블을 무용지물로 만들 수 있다.

      혹시나 솔트가 패스워드와 같이 털리더라도 레인보우 테이블이 무용지물이 되었기 때문에 단순 해시 함수를 사용하는 것보다는 효율적이다.

      이 솔트가 같이 털리지 않기 위해 다른 곳에 저장한다면 그것은 페퍼라고 부른다.


    일반적으로 키 스트레칭과 솔트를 섞어서 사용한다.
    
    ---
    
    [https://d2.naver.com/helloworld/318732](https://d2.naver.com/helloworld/318732)


# 테스트
### repository를 테스트할까 말까?
    
    테스트를 한다. 
    
    사실 테스트를 안하는 것이 낫다. 왜냐하면 통합 테스트만으로도 충분히 테스트가 되기 때문이고 repository의 메소드들이 간단하고 회귀문제가 거의 일어나지 않기 때문에 (기능 추가나 코드 수정으로 SQL에 문제가 생기지 않는다) 테스트의 가치가 낮다. 
    
    하지만 나는 아직 SQL과 Mybatis가 익숙하지 않기 때문에 매번 수정하거나 개발하면서 잘되는지 테스트가 필요하고 통합테스트는 느리기 때문에 간단하게라도 테스트를 가져가는 것이 좋을 것 같다.
    
### service 계층은 repository를 mocking 할까 말까?
    
    mocking은 정말 필요한 상황이 아니라면 ex 외부 API와 함께 테스트 mocking하지 않는 것이 나은 것 같다.
    
    왜냐하면 구현 세부사항에 묶이기 때문에 테스트가 깨지기 쉽고 가독성 또한 안 좋기 때문이다. 
    
    하지만 써보지도 않고 판단하는 것도 이상하고 써야하는 경우가 있기 때문에 service에 repository를 mocking함으로써 mocking을 연습해보고 싶다.
    
### controller 영역을 어떻게 자동적으로 테스트할 것이고 하위 레이어를 mocking할 것인가?

    controller layer는 MockMVC를 이용하고 service는 마찬가지로 mock 연습을 위해 mock을 사용한다.

    사실 controller layer는 repository처럼 통합 테스트로 충분하다고 생각하지만 아직 스프링이 익숙하지 않기 때문에 짧은 단위로 controller도 테스트해가면서 개발하는게 나을 것 같다

    매번 controller영역을 개발하고 통합테스트로 확인하면 시간이 오래 걸리기 때문이다.
    
### 통합 테스트는 어떻게 할 것인가?

    MockMVC를 통해 첫 시작점인 필터부터 마지막 리턴 값에 대해서 알맞은 리턴 값이 나가는지 테스트 한다. 

    이 때는 실제 MySQL DB를 비롯하여 모두 실제 객체를 이용하여 테스트한다.
# CI / CD
### CI/CD란?
    
    시장과 고객의 요구에 빠르게 반응해서 제품을 출시 업데이트하는 것이 중요하다.
    
    CI/CD는 이를 위해 어플리케이션 개발부터 배포까지 모든 단계들을 자동화를 통해서 더 효율적이고 빠르게 사용자에게 빈번이 배포할 수 있게 만드는 것을 말한다.
    
    - CI(Continuous Integration)
        
        CI는 개발자가 코드를 머지했을 때 빌드가 잘 되는지, 모든 테스트를 통과하는지를 자동으로 해주는 것을 의미한다. 또한 CI는 개발자가 의식적으로 작은 단위로 커밋하는 것을 포함한다. 
        
        이를 통해 버그를 조기에 발견할 수 있고 거대한 머지를 처리하는데 드는 시간을 아낄 수 있다.
        
        - 세부 단계
            1. 개발자가 코드를 작성해서 PR을 올린다.
            2. 리뷰가 통과되면 머지를 시도한다.
            3. 머지된 코드는 빌드와 테스트를 위한 서버에서 자동으로 내려받는다.
            4. 빌드와 테스트를 진행하고 만약 실패하면 개발자에게 알려준다.
            5. 비드와 테스트를 진행하고 만약 성공하면 CD단계로 넘어간다. 
    - CD(Continuous Integration)
        
        CI를 통해 빌드와 테스트가 끝난 코드를 자동으로 릴리스해주는 것을 의미한다.
        
    
    ### 전체 과정
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/146e295e-654e-4803-8e43-63a563aeeebd/Untitled.png)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e854f37-d3a5-4c17-99f1-9a8c84018d3a/Untitled.png)
    
    ---
    
    [https://www.youtube.com/watch?v=0Emq5FypiMM](https://www.youtube.com/watch?v=0Emq5FypiMM)- 드림코딩 CI 편
    
    [https://engineering.linecorp.com/ko/blog/build-a-continuous-cicd-environment-based-on-data/](https://engineering.linecorp.com/ko/blog/build-a-continuous-cicd-environment-based-on-data/)
    
    질문
    
    1. 머지했을 때 빌드 또는 테스트가 실패하면 머지가 실패하는 것인가요 아니면 머지는 그대로 되어 있는 걸까요? 
    2. 만약 머지가 그대로 되어 있다면 머지를 다시 취소하고 문제 있는 부분을 해결한 후 다시 머지해야 하는 걸까요? 실제로 어떤 과정일지 궁금합니다.
    3. develop 브랜치가 메인 브랜치이고 feature 브랜치가 있다면 보통은 feature 브랜치에서 develop 브랜치로 머지할 때만 CI가 동작해서 빌드하고 테스트해보는 건가요? 아니면 로컬 컴퓨터에서 원격에 feature 브랜치로 push할 때도 CI가 동작하도록 하나요?
### CI/CD 툴은 뭐가 있고 각각의 장단점은?
    
    고려 사항 : 예산, 프로젝트 요구사항
    
    선택시 고려 사항
    
    1. 프로젝트에 사용된 모든 언어를 지원해야 한다.
    2. 컨테이너 오케스트레이션 시스템을 지원하는게 좋음
    3. 문서가 잘되어 있는지, 지원 포럼이 잘 운영되는지
    4. 팀에 각 개발자가 잘 이해하고 있는지
    
    ---
    
    [https://loosie.tistory.com/789](https://loosie.tistory.com/789)
    
    [https://www.lambdatest.com/blog/travis-ci-vs-jenkins/](https://www.lambdatest.com/blog/travis-ci-vs-jenkins/)
    [https://www.lambdatest.com/learning-hub/cicd](https://www.lambdatest.com/learning-hub/cicd)
    
    [https://www.devopsauthority.tech/2021/02/09/which-is-better-github-actions-circle-ci/](https://www.devopsauthority.tech/2021/02/09/which-is-better-github-actions-circle-ci/)


# 고민

### Mybatis에서 resultMap을 single join 방식을 쓸까 multiple select 방식을 쓸까?
    
    single join 방식이 더 성능이 좋기 때문에 single join 방식을 사용한다.
    
### 어노테이션은 어떤 순서로 놓는 것이 좋을까?
    
    중요한 것을 클래스에 가장 가깝게 두는 것이 좋다.
    
    예를 들어 다음과 같은 코드가 있을 때
    
    @Getter
    @Service
    public class Something{
    }
    
    @Getter는 롬복의 어노테이션이고 필수적인 것은 아니다. 반면에 @Service는 스프링의 어노테이션으로 중요한 어노테이션이다. 만약 이런 식으로 구분해서 놓는다면 후에 kotilin 등의 새 언어 전환으로 롬복이 더 이상 필요없을 때 쉽게 제거할 수 있다.
    
    ---
    
    스프링 부트와 AWS로 혼자 구현하는 웹 서비스 89p
    
### Entity를 따로 관리하는게 좋을까? Dto로만 해결할까?
    
    Jpa와 달리 Mybatis에서는 Entitiy를 테이블로 매핑하지 않는다.
    
    하지만 Entity에 관한 작업들은 Entity가 주체를 갖고 처리해야지 service에서 모든 것들을 담당하는 것은 객체가 단순히 데이터 저장소에 역할만하게 되기 때문에 옳바르지 않다.
    
    service는 트랜잭션과 domain들의 실행순서를 조정하는 역할을 하고 실제 비즈니스 로직은 domain들이 담당하는 것이 좋다.
    
    결합도를 떨어트려 변경에 유연하게 해주기 때문이다.
    
    Repository에서는 실제 Entity로 받아오고 service에서 이 Entitiry로 작업한 후에 Controller로 넘겨줄 때는 Dto를 사용하여 넘겨주는 방식으로 하자. 왜냐하면 Controller는 View에 필요한 정보들에 맞춰 Dto가 구성되어야 하기 때문에 Entitiy만으로는 충분하지 않을 때가 있고 View 요구사항에 맞춰 Entity를 변경하는 것은 좋지 않다. 왜냐하면 View는 요구사항이 자주 바뀌며 Entity는 서비의 중심축에 있기 때문에 Entity가 변경된다면 많은 곳에 영향을 끼칠 수 있기 때문이다.
    
    ---
    
    스프링 부트와 Aws로 혼자 구현하는 웹서비스 100-108p
    
### 빌더 패턴을 사용하면 좋은 이유?
    1. 클래스에 많은 필드가 존재하면서 항상 모든 필드가 필요한 것이 아닐 때가 있다.이 때 각 상황에 맞는 무수히 많은 생성자를 만드는 것은 낭비다. 빌더 패턴을 사용한다면 원하는 필드만 그 때 그 때 넣어서 생성할 수 있다.
    2. 또한 내가 어떤 값을 넣는지 명확하게 알 수 있으므로 실수할 여지가 적다.
        
        public Something(String a, String b ){
        }
        
        public static void main(){
        	new Something("b", "a"); //이렇게 필요한 값을 거꾸로 넣어도 인지가 잘 안된다.
        }
        
    3. 빈 생성자를 이용해서 만든 후 Setter로 넣어줄 수도 있지만, 필요한 객체가 만들어질 때까지 아직 덜 생성된 객체가 버젓이 생성되어 있는 셈이므로 멀티쓰레드 환경에서 불완전한 객체를 사용해서 문제가 될 가능성이 존재한다.
    
    ---
    
    스프링 부트와 Aws로 혼자 구현하는 웹서비스 91-94p
    
### 롬복에 빌더를 메소드에 붙힌 이유?
    
    Mybatis에서 매핑할 때 인자가 없는 생성자가 필요하다.
    그런데 class 레벨에 builder를 붙히면 다른 생성자가 존재할 경우 제대로 작동하지 않기 때문에 메소드에 붙혔다.
    
### 중복체크, null 체크 같이 DB에서 제한할 수 있는 것들은 DB로 넘겨도 되지 않을까?
    
    애플리케이션 단에서도 체크해주는 것이 좋다. 
    
    1. 왜냐하면 비즈니스 로직 자체만으로 스펙과 요구사항을 분석할 수 있다.(유니크 처리는 DB에 맡기고, 다른 체크 로직은 자바 소스에서 하고 하면 파악하기가 관점에 따라 복잡할 수 있다.)
    2. DB가 변경 될 일이 발생하더라도, 비즈니스 로직에만 집중할 수 있습니다. 예를 들면, 먼 훗날(현재는 그런 설계안이 아니지만) 유저 탈퇴 처리 시 DB에 1년동안은 정보를 보관해야하는 요구사항이 생겼습니다. 유저 데이터에 Status라는 값을 두고, 액티브 유저인지, 탈퇴 유저인지 판단해야하는 경우가 있을 수 있습니다.(실제로 이렇게 많이 하고, 법적으로 이런 필요가 많습니다.) 이럴 경우 DB의 unique인덱스를 제거하기 때문에 DB만으로 중복체크를 하던 부분에 문제가 발생한다. 만약 애플리케이션단에서도 체크해주고 있었다면 DB 변화에 관계없이 잘 동작할 것이다.
    
    ---
    
    derek 멘토님
    
### BaseException이 Exception이 아니라 RuntimeException을 상속하는 이유는?
    
    checked Exception은 모두 try catch로 잡아주어야 한다. 그러나 내가 직접 만드는 예외들은 거의 대부분 잡아서 해줄 것이 없다. 
    그냥 위로 날려보내서 ControllerAdvice가 처리하게끔 하는게 깔끔하다. 따라서 RuntimeException을 상속한다.

### 잘못된 인풋으로 Controller에서 @RequestBody가 붙어 있는 클래스에 JsonMapping 실패시 어떻게 처리할까?
    잘못된 인풋이 여러개라도 하나만 알려준다. 여러개 모두를 알려주기엔 구현 난이도가 높고 공수 대비 효과가 크지 않기 때문이다. 
    왜냐하면 UI단에서 충분히 옳바른 타입으로 유도할 수 있고 여러 인풋이 한번에 잘못된 타입으로 요청할 일이 거의 없기 때문이다.

### 두 명이 같은 아이디로 동시에 가입하는 것을 어떻게 처리할까?
    - Java Synchronized로 회원가입 메소드에 락을 건다.

      → 서버 여러대를 사용하고 각기 다른 JVM에서 동시에 가입하면 무용지물이다.

    - DB에 unique속성에 맡기기

      → 어플리케이션 단에서는 통과되어도 DB단에서 막아줄 수 있다. 하지만 비즈니스 요구사항이 탈퇴한 유저에 대해서 1년동안 정보를 보관해야 한다면 unique를 해제해야 한다. 아직 아이디를 보관 중이지만 탈퇴한 id로 새로 가입가능해야하기 때문. 이 경우 무용지물이다.

      → 하지만 탈퇴한 유저 정보를 새로운 테이블에 보관한다면 계속 unique 제약조건을 유지할 수 있다.

      ⇒ 이 방식은 간단하면서도 성능적으로 문제가 되지 않게 동시성 이슈를 해결해주기 때문에 이 방법으로 결정.

    - MySQL의 SELECT FOR UPDATE를 활용한 비관적 락 혹은 낙관적 락을 사용

      → 아직 존재하지 않는 row에 대해서는 mysql의 select for update가 잠금을 진행하지 않는다. 낙관적 락 또한 아직 존재하지 않는 row에 대해서는 version등을 관리할 수 없어서 불가능하다.

      → 가입 과정을 가입 예약 , 가입 완료 두 단계로 나누면 비관적 락과 낙관적 락 방식을 사용할 수 있다.

      예를 들면 다음과 같은 방식이다.

        - 비관적 락
            1. 동시에 두 사람이 'a'라는 아이디로 가입하면 회원 테이블에 'a'라는 아이디에 레코드 두 개가 가입 예약 상태로 생긴다.
            2. 가입 예약 상태를 바꾸기 위하여 'a'라는 아이디를 select for update로 조회했더니 레코드 2개가 나온다. 자신이 생성했던 레코드 1개를 가입 완료로 바꾸고 나머지 한 개의 요청은 삭제한다. 다른 요청도 마찬가지로 가입완료로 바꾸기 위하여 'a'라는 아이디로 select for update를 한다. 근데 이 예약 중인 row는 앞 요청에 의해서 삭제되고 없으므로 이 요청은 가입 실패하게 된다.
        - 낙관적 락

            1. 동시에 두 사람이 'a'라는 아이디로 가입하면 회원 테이블에 'a'라는 아이디에 레코드 두개가 가입 예약 상태로 생긴다.

            2. 한 요청이 가입 완료 상태로 바꾸기 위하여 'a'라는 아이디로 select를 한다. 결과가 1개가 아니라 2개이므로 2개의 레코드를 모두 삭제하고 가입에 실패한다. 뒤 요청은 'a'라는 아이디로 select했더니 가입 대기 레코드가 아무것도 없어서 가입에 실패한다.

    - LOCK TABLE WRITE으로 테이블을 잠그기

      가능한 방법이지만 테이블 전체를 잠궈서 다른 트랜잭션은 읽지도 쓰지도 못하게하는 방법이기 때문에 회원 테이블에 작업하는 모든 세션들이 기다려야 해서 성능상 좋지 않다.

    - Redis나 MySQL 네임드락을 이용하여 분산 락을 구현하기
        1. Redis. 이용

           회원가입하는 요청들이 Redis에서 key를 생성하면서 lock을 얻어야지 가능하도록 한다. 이 경우 문제를 해결할 수 있지만, Redis 서버를 따로 운영해주어야 한다는 부담이 있다.

        2. Mysql 네임드락 이용

           네임드 락을 이용하여 회원 가입에 대해 모두 ”join[유저 아이디]”이라는 이름을 가진 같은 lock을 얻게 한다. 이렇게하면 서로 같은 아이디로 가입하는 유저들만 락이 걸리므로 쉽게 구현할 수 있다. 하지만 추가적으로 구현해줘야 할 부분이 있어서 구현하기 번거롭다.
            
           ---

           [https://techblog.woowahan.com/2631/](https://techblog.woowahan.com/2631/)
