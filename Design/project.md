# 회원가입 / 로그인
## 인증 / 인가
### 인증이란?
    
    인증이란 사용자가 등록된 사용자인지를 확인하는 것이며, 사용자가 보낸 메시지가 변조되지 않은 그대로의 것인지를 확인하는 것이다.
    
    첫번째 작업은 아이디와 패스워드를 가입 목록에서 대조하는 방식을 사용하고 두번째 작업은 메시지 인증 부호, 디지털 서명 부호 등이 사용된다.
    
    ---
    
    [https://terms.naver.com/entry.naver?docId=855723&cid=42346&categoryId=42346]
    
### 인가란?
    
    사용자가 특정한 서비스를 사용할 수 있는 권한이 있는지 확인하는 절차. 예를 들어 어떤 글을 수정한다거나 관리자 페이지에 들어간다거나 하는 것 들이 모두 권한이 필요하다. 이러한 일들을 할려면 서버로부터 인가를 받아야 한다.
    
    ---
    
    [https://terms.naver.com/entry.naver?docId=849375&cid=50371&categoryId=50371]

## JWT
### JWT란 무엇이고 어떻게 구성되어 있을까?
    
    Json Web Token의 줄임말로 클라이언트가 이 토큰을 이용해 서버에 인증할 수 있다. 
    
    `HEADER.PAYLOAD.SIGNATURE` 형태로 구성되어 있다.
    
    - 헤더
        
        시그니쳐를 만들 때 사용된 알고리즘과 JWT타입이 적혀 있다.
        
        {
          "alg": "HS256",
          "typ": "JWT"
        }
        
    - PALOAD
        
        유저에 대한 정보와 토큰의 만료 시간 등이 적혀 있다. [Standard field](https://en.wikipedia.org/wiki/JSON_Web_Token#:~:text=database%20multiple%20times.-,Standard%20fields,-%5Bedit%5D)의 필드를 사용하거나 사용자가 정의한 필드를 사용한다.
        
        {
          "sub": "1234567890",
            "loggedInAs": "admin", // 권한
          "name": "John Doe", // 유저 이름
          "iat": 1516239022 // 토큰이 생성된 시간
        }
        
    - SIGNATURE
        
        헤더와 페이로드를 서버의 비밀키를 이용해서 암호화한 암호문이 들어간다.
        
        HMACSHA256(
          base64UrlEncode(header) + "." +
          base64UrlEncode(payload),
          secret // 비밀키
        )
        
    
    최종 JWT 생성
    
    **`const jwt** = base64urlEncoding(header) + '.' + base64urlEncoding(payload) + '.' + base64urlEncoding(signature)`
    
    `=>` 
    
    `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.kXvDp1PP_ndNG3MhIq1jvfvT6nfdGHW2xEZ5gFgo95A`
    
    ---
    
    [https://en.wikipedia.org/wiki/JSON_Web_Token](https://en.wikipedia.org/wiki/JSON_Web_Token)
    
### JWT를 이용한 로그인은 어떻게 동작할까?
    
    서버는 유저가 로그인하면 로그인 정보를 확인한 후 JWT 토큰을 만들어서 내려보낸다. 유저는 매 요청마다 JWT 토큰을 함께보낸다.
    
    서버는 HEADER.PAYLOAD와 비밀키를 이용해 HEADER에 있는 알고리즘으로 암호문을 생성한다. 생성된 암호문과 SIGNATURE를 비교해서 둘이 동일하면 위변조되지 않은 것이므로 이 JWT토큰이 유효하다고 판단한다.
    
    그 후 JWT에 적힌 내용을 이용해(유저 아이디나 권한) 처리를 진행한다.
    
### JWT 방식의 문제점은 무엇이고 어떻게 해결할까?
    - 문제점
        
        토큰이 탈취당하면 유효기간동안 해커가 마음대로 로그인할 수 있으며 탈취된 사실을 알아도 토큰을 만료시킬 수 있는 방법이 없다.
        
    - 해결 방법
        
        access token의 만료 시간을 짧게 준다.
        
        - 문제점
            
            access token의 만료 시간을 짧게 주면 유저가 계속해서 로그인을 다시해주어야 하는 불편함이 있다.
            
            - 해결방법
                - access token의 만료 시간을 짧게 주고 만료 시간이 긴 refresh token을 같이 사용한다.
                    
                    서버는 사용자에게 access token과 refresh token을 같이 발급한다. 사용자는 access token이 만료되면 refresh token을 같이 서버로 보내고 서버는 refresh token을 자신이 갖고 있는 refresh token과 비교하여 유효한지 확인하고 access token을 갱신해준다. 이렇게 함으로써 만약 access token이 탈취당하더라도 유효시간이 짧기 때문에 해커가 사용하기가 어렵고 refresh token이 탈취당하면 서버가 자신이 갖고 있는 refresh token을 만료시킴으로써 대응할 수 있다.
                    
                    또한 refresh token은 access token보다 훨씬 덜 보내지므로 탈취 가능성을 줄일 수 있다.
                    
                    - 어떻게  탈취 당한 사실을 알아낼까?
                        1. Refresh Token은 한 번만 사용하게하고 매번 Refresh Token도 재발급해주기 (RTR 방식)
                            
                            해커가 Refresh Token을 탈취한 후 사용하려하면 이미 한 번 사용된 Refresh Token이 재사용되는 것이므로 탈취당했다는 사실을 알 수 있다. [출처](https://developer-ping9.tistory.com/239#:~:text=%C2%A0%20%C2%A0%20%C2%A0*-,%5BRTR%20%EA%B8%B0%EB%B2%95%EC%97%90%20%EB%8C%80%ED%95%9C%20%EC%A7%A4%EB%A7%89%EC%A0%95%EB%A6%AC%5D,-Refresh%20Token%20%EC%9D%84)
                            
                        2. IP 주소를 확인하기 [출처](https://okky.kr/article/1007579#:~:text=IP%20%EC%A3%BC%EC%86%8C%EB%A1%9C%20%EC%9A%94%EC%B2%AD%EC%9D%B4%20%EB%93%A4%EC%96%B4%EC%99%94%EB%8B%A4%EB%8D%98%EA%B0%80%20%EB%98%90%EB%8A%94)
                    - 문제점
                        1. 서버에 refresh token을 보관하는 storage를 따로 만들어야 한다. jwt의 장점이 완전히 사라진다.
                        2. 클라이언트가 AccessToken의 만료에 대한 연장 요청을 구현해야 한다.
                - Sliding Session 전략사용하기
                    
                    사용자가 유효한 access token을 들고 접근할 때마다 access token의 만료 시간을 되돌려주는 것이다. 매 요청마다 돌려주진 않고 글을 쓸 때나 결제할 때와 같이 특별히 세션 유지가 필요한 순간에 돌려준다. 만약 만료 시간이 30분으로 설정되어 있는데 사용자가 5분 남은 access token을 사용하면 다시 30분으로 돌려준다.
                    
                    이렇게하면 사용자가 지속적으로 서비스를 사용하는 동안은 중간에 다시 로그인하지 않아도 되며 탈취된 토큰은 해커가 바로 사용해서 지속적으로 access token의 만료시간을 갱신해주지 않는 이상 곧 만료가 되므로 유저의 편희성과 보안 둘 다 어느정도 향상시킬 수 있다.

## 패스워드 암호화
### 패스워드는 왜 DB에 암호화해서 저장해야할까?

      패스워드는 사용자 인증할 때 말고는 사용되지 않는다.

      이 인증은 복호화가 불가능한 암호화 방식을 사용하더라도 구현할 수 있다.

      이렇게 해두면 해커한테 DB가 털리더라도 암호화된 패스워드는 해독이 불가능하기 때문에 안전하다.

      여러 웹사이트에서 비밀번호 찾기를 했을 때 그대로 비밀번호를 알려주는게 아니라 새 비밀번호로 바꾸도록하는 이유는 비밀번호가 암호화되어 있기 때문이다.

      또한 법으로도 암호화하도록 정해져 있다.

### 단순 해시 함수로는 복호화가 불가능하더라도 비밀번호가 안전하지 않다 왜그럴까?

      왜냐하면 해커는 다이제스트를 얻어 브루트포스 공격을 통해 원문을 알아낼 수 있기 때문이다.

      브루트포스 공격은 영문 + 숫자 조합 같이 패스워드로 그럴듯한 값들을 무차별적으로 해시 함수에 대입하여 탈취된 다이제스트와 동일한 값을 갖는지 비교하여 원문을 알아내는 방법이다.

      해시 함수가 아무리 빠르더라도 이 작업에는 시간이 많이 걸린다. 따라서 레인보우 테이블이라는 것을 같이 사용하는데 이것은 그럴듯한 비밀번호와 그것의 다이제스트가 무수히 많이 저장되어 있는 테이블이다.

      이 테이블과 탈취한 다이제스트를 이용하여 브루트포스 공격을 더 빠르게 성공시킬 수 있다.

### 단순 해시 함수를 보완하는 방법은 무엇이 있을까?
    - 키 스트레칭(key stretch) 방법

      패스워드를 해싱 함수를 통하여 다이제스트를 얻어낸다.

      이 다이제스트를 해싱 함수를 통하여 새로운 다이제스트를 얻어낸다.

      이런 식으로 여러 번 반복해서 최종 다이제스트를 얻어서 저장하는 방법이다.

      이 방법의 장점은 원문으로부터 최종 다이제스트를 얻기까지 걸리는 시간을 늘리는데 있다.

      해커가 단순 해시 함수를 통해 1초에 50억번 대입해볼 수 있었다면, 키 스트레칭이 적용된 다이제스트를 사용하면 1초에 5번밖에 대입하지 못하게 만들 수 있다.

    - 솔트(salt) 알고리즘

      패스워드에다가 임의적인 값을 덧붙힌 후 해시 함수를 적용하는 방법이다.

      솔트가 붙은 비밀번호는 일반적인 비밀번호와 완전히 달라지기 때문에 브루트포스 공격으로 뚫기가 쉽지 않으며 레인보우 테이블을 무용지물로 만들 수 있다.

      혹시나 솔트가 패스워드와 같이 털리더라도 레인보우 테이블이 무용지물이 되었기 때문에 단순 해시 함수를 사용하는 것보다는 효율적이다.

      이 솔트가 같이 털리지 않기 위해 다른 곳에 저장한다면 그것은 페퍼라고 부른다.


    일반적으로 키 스트레칭과 솔트를 섞어서 사용한다.
    
    ---
    
    [https://d2.naver.com/helloworld/318732](https://d2.naver.com/helloworld/318732)


# 테스트
### repository를 테스트할까 말까?
    
    테스트를 한다. 
    
    사실 테스트를 안하는 것이 낫다. 왜냐하면 통합 테스트만으로도 충분히 테스트가 되기 때문이고 repository의 메소드들이 간단하고 회귀문제가 거의 일어나지 않기 때문에 (기능 추가나 코드 수정으로 SQL에 문제가 생기지 않는다) 테스트의 가치가 낮다. 
    
    하지만 나는 아직 SQL과 Mybatis가 익숙하지 않기 때문에 매번 수정하거나 개발하면서 잘되는지 테스트가 필요하고 통합테스트는 느리기 때문에 간단하게라도 테스트를 가져가는 것이 좋을 것 같다.
    
### service 계층은 repository를 mocking 할까 말까?
    
    mocking은 정말 필요한 상황이 아니라면 ex 외부 API와 함께 테스트 mocking하지 않는 것이 나은 것 같다.
    
    왜냐하면 구현 세부사항에 묶이기 때문에 테스트가 깨지기 쉽고 가독성 또한 안 좋기 때문이다. 
    
    하지만 써보지도 않고 판단하는 것도 이상하고 써야하는 경우가 있기 때문에 service에 repository를 mocking함으로써 mocking을 연습해보고 싶다.
    
### controller 영역을 어떻게 자동적으로 테스트할 것이고 하위 레이어를 mocking할 것인가?

    controller layer는 MockMVC를 이용하고 service는 마찬가지로 mock 연습을 위해 mock을 사용한다.

    사실 controller layer는 repository처럼 통합 테스트로 충분하다고 생각하지만 아직 스프링이 익숙하지 않기 때문에 짧은 단위로 controller도 테스트해가면서 개발하는게 나을 것 같다

    매번 controller영역을 개발하고 통합테스트로 확인하면 시간이 오래 걸리기 때문이다.
    
### 통합 테스트는 어떻게 할 것인가?

    MockMVC를 통해 첫 시작점인 필터부터 마지막 리턴 값에 대해서 알맞은 리턴 값이 나가는지 테스트 한다. 

    이 때는 실제 MySQL DB를 비롯하여 모두 실제 객체를 이용하여 테스트한다.
# CI / CD
### CI/CD란?
    
    시장과 고객의 요구에 빠르게 반응해서 제품을 출시 업데이트하는 것이 중요하다.
    
    CI/CD는 이를 위해 어플리케이션 개발부터 배포까지 모든 단계들을 자동화를 통해서 더 효율적이고 빠르게 사용자에게 빈번이 배포할 수 있게 만드는 것을 말한다.
    
    - CI(Continuous Integration)
        
        CI는 개발자가 코드를 머지했을 때 빌드가 잘 되는지, 모든 테스트를 통과하는지를 자동으로 해주는 것을 의미한다. 또한 CI는 개발자가 의식적으로 작은 단위로 커밋하는 것을 포함한다. 
        
        이를 통해 버그를 조기에 발견할 수 있고 거대한 머지를 처리하는데 드는 시간을 아낄 수 있다.
        
        - 세부 단계
            1. 개발자가 코드를 작성해서 PR을 올린다.
            2. 리뷰가 통과되면 머지를 시도한다.
            3. 머지된 코드는 빌드와 테스트를 위한 서버에서 자동으로 내려받는다.
            4. 빌드와 테스트를 진행하고 만약 실패하면 개발자에게 알려준다.
            5. 비드와 테스트를 진행하고 만약 성공하면 CD단계로 넘어간다. 
    - CD(Continuous Integration)
        
        CI를 통해 빌드와 테스트가 끝난 코드를 자동으로 릴리스해주는 것을 의미한다.
        
    
    ### 전체 과정
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/146e295e-654e-4803-8e43-63a563aeeebd/Untitled.png)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e854f37-d3a5-4c17-99f1-9a8c84018d3a/Untitled.png)
    
    ---
    
    [https://www.youtube.com/watch?v=0Emq5FypiMM](https://www.youtube.com/watch?v=0Emq5FypiMM)- 드림코딩 CI 편
    
    [https://engineering.linecorp.com/ko/blog/build-a-continuous-cicd-environment-based-on-data/](https://engineering.linecorp.com/ko/blog/build-a-continuous-cicd-environment-based-on-data/)
    
    질문
    
    1. 머지했을 때 빌드 또는 테스트가 실패하면 머지가 실패하는 것인가요 아니면 머지는 그대로 되어 있는 걸까요? 
    2. 만약 머지가 그대로 되어 있다면 머지를 다시 취소하고 문제 있는 부분을 해결한 후 다시 머지해야 하는 걸까요? 실제로 어떤 과정일지 궁금합니다.
    3. develop 브랜치가 메인 브랜치이고 feature 브랜치가 있다면 보통은 feature 브랜치에서 develop 브랜치로 머지할 때만 CI가 동작해서 빌드하고 테스트해보는 건가요? 아니면 로컬 컴퓨터에서 원격에 feature 브랜치로 push할 때도 CI가 동작하도록 하나요?
### CI/CD 툴은 뭐가 있고 각각의 장단점은?
    
    고려 사항 : 예산, 프로젝트 요구사항
    
    선택시 고려 사항
    
    1. 프로젝트에 사용된 모든 언어를 지원해야 한다.
    2. 컨테이너 오케스트레이션 시스템을 지원하는게 좋음
    3. 문서가 잘되어 있는지, 지원 포럼이 잘 운영되는지
    4. 팀에 각 개발자가 잘 이해하고 있는지
    
    ---
    
    [https://loosie.tistory.com/789](https://loosie.tistory.com/789)
    
    [https://www.lambdatest.com/blog/travis-ci-vs-jenkins/](https://www.lambdatest.com/blog/travis-ci-vs-jenkins/)
    [https://www.lambdatest.com/learning-hub/cicd](https://www.lambdatest.com/learning-hub/cicd)
    
    [https://www.devopsauthority.tech/2021/02/09/which-is-better-github-actions-circle-ci/](https://www.devopsauthority.tech/2021/02/09/which-is-better-github-actions-circle-ci/)


# 고민

### Mybatis에서 resultMap을 single join 방식을 쓸까 multiple select 방식을 쓸까?
    
    single join 방식이 더 성능이 좋기 때문에 single join 방식을 사용한다.
    
### 어노테이션은 어떤 순서로 놓는 것이 좋을까?
    
    중요한 것을 클래스에 가장 가깝게 두는 것이 좋다.
    
    예를 들어 다음과 같은 코드가 있을 때
    
    @Getter
    @Service
    public class Something{
    }
    
    @Getter는 롬복의 어노테이션이고 필수적인 것은 아니다. 반면에 @Service는 스프링의 어노테이션으로 중요한 어노테이션이다. 만약 이런 식으로 구분해서 놓는다면 후에 kotilin 등의 새 언어 전환으로 롬복이 더 이상 필요없을 때 쉽게 제거할 수 있다.
    
    ---
    
    스프링 부트와 AWS로 혼자 구현하는 웹 서비스 89p
    
### Entity를 따로 관리하는게 좋을까? Dto로만 해결할까?
    
    Jpa와 달리 Mybatis에서는 Entitiy를 테이블로 매핑하지 않는다.
    
    하지만 Entity에 관한 작업들은 Entity가 주체를 갖고 처리해야지 service에서 모든 것들을 담당하는 것은 객체가 단순히 데이터 저장소에 역할만하게 되기 때문에 옳바르지 않다.
    
    service는 트랜잭션과 domain들의 실행순서를 조정하는 역할을 하고 실제 비즈니스 로직은 domain들이 담당하는 것이 좋다.
    
    결합도를 떨어트려 변경에 유연하게 해주기 때문이다.
    
    Repository에서는 실제 Entity로 받아오고 service에서 이 Entitiry로 작업한 후에 Controller로 넘겨줄 때는 Dto를 사용하여 넘겨주는 방식으로 하자. 왜냐하면 Controller는 View에 필요한 정보들에 맞춰 Dto가 구성되어야 하기 때문에 Entitiy만으로는 충분하지 않을 때가 있고 View 요구사항에 맞춰 Entity를 변경하는 것은 좋지 않다. 왜냐하면 View는 요구사항이 자주 바뀌며 Entity는 서비의 중심축에 있기 때문에 Entity가 변경된다면 많은 곳에 영향을 끼칠 수 있기 때문이다.
    
    ---
    
    스프링 부트와 Aws로 혼자 구현하는 웹서비스 100-108p
    
### 빌더 패턴을 사용하면 좋은 이유?
    1. 클래스에 많은 필드가 존재하면서 항상 모든 필드가 필요한 것이 아닐 때가 있다.이 때 각 상황에 맞는 무수히 많은 생성자를 만드는 것은 낭비다. 빌더 패턴을 사용한다면 원하는 필드만 그 때 그 때 넣어서 생성할 수 있다.
    2. 또한 내가 어떤 값을 넣는지 명확하게 알 수 있으므로 실수할 여지가 적다.
        
        public Something(String a, String b ){
        }
        
        public static void main(){
        	new Something("b", "a"); //이렇게 필요한 값을 거꾸로 넣어도 인지가 잘 안된다.
        }
        
    3. 빈 생성자를 이용해서 만든 후 Setter로 넣어줄 수도 있지만, 필요한 객체가 만들어질 때까지 아직 덜 생성된 객체가 버젓이 생성되어 있는 셈이므로 멀티쓰레드 환경에서 불완전한 객체를 사용해서 문제가 될 가능성이 존재한다.
    
    ---
    
    스프링 부트와 Aws로 혼자 구현하는 웹서비스 91-94p
    
### 롬복에 빌더를 메소드에 붙힌 이유?
    
    Mybatis에서 매핑할 때 인자가 없는 생성자가 필요하다.
    그런데 class 레벨에 builder를 붙히면 다른 생성자가 존재할 경우 제대로 작동하지 않기 때문에 메소드에 붙혔다.
    
### 중복체크, null 체크 같이 DB에서 제한할 수 있는 것들은 DB로 넘겨도 되지 않을까?
    
    애플리케이션 단에서도 체크해주는 것이 좋다. 
    
    1. 왜냐하면 비즈니스 로직 자체만으로 스펙과 요구사항을 분석할 수 있다.(유니크 처리는 DB에 맡기고, 다른 체크 로직은 자바 소스에서 하고 하면 파악하기가 관점에 따라 복잡할 수 있다.)
    2. DB가 변경 될 일이 발생하더라도, 비즈니스 로직에만 집중할 수 있습니다. 예를 들면, 먼 훗날(현재는 그런 설계안이 아니지만) 유저 탈퇴 처리 시 DB에 1년동안은 정보를 보관해야하는 요구사항이 생겼습니다. 유저 데이터에 Status라는 값을 두고, 액티브 유저인지, 탈퇴 유저인지 판단해야하는 경우가 있을 수 있습니다.(실제로 이렇게 많이 하고, 법적으로 이런 필요가 많습니다.) 이럴 경우 DB의 unique인덱스를 제거하기 때문에 DB만으로 중복체크를 하던 부분에 문제가 발생한다. 만약 애플리케이션단에서도 체크해주고 있었다면 DB 변화에 관계없이 잘 동작할 것이다.
    
    ---
    
    derek 멘토님
    
### BaseException이 Exception이 아니라 RuntimeException을 상속하는 이유는?
    
    checked Exception은 모두 try catch로 잡아주어야 한다. 그러나 내가 직접 만드는 예외들은 거의 대부분 잡아서 해줄 것이 없다. 
    그냥 위로 날려보내서 ControllerAdvice가 처리하게끔 하는게 깔끔하다. 따라서 RuntimeException을 상속한다.

### 잘못된 인풋으로 Controller에서 @RequestBody가 붙어 있는 클래스에 JsonMapping 실패시 어떻게 처리할까?
    잘못된 인풋이 여러개라도 하나만 알려준다. 여러개 모두를 알려주기엔 구현 난이도가 높고 공수 대비 효과가 크지 않기 때문이다. 
    왜냐하면 UI단에서 충분히 옳바른 타입으로 유도할 수 있고 여러 인풋이 한번에 잘못된 타입으로 요청할 일이 거의 없기 때문이다.

### 두 명이 같은 아이디로 동시에 가입하는 것을 어떻게 처리할까?
    - Java Synchronized로 회원가입 메소드에 락을 건다.

      → 서버 여러대를 사용하고 각기 다른 JVM에서 동시에 가입하면 무용지물이다.

    - DB에 unique속성에 맡기기

      → 어플리케이션 단에서는 통과되어도 DB단에서 막아줄 수 있다. 하지만 비즈니스 요구사항이 탈퇴한 유저에 대해서 1년동안 정보를 보관해야 한다면 unique를 해제해야 한다. 아직 아이디를 보관 중이지만 탈퇴한 id로 새로 가입가능해야하기 때문. 이 경우 무용지물이다.

      → 하지만 탈퇴한 유저 정보를 새로운 테이블에 보관한다면 계속 unique 제약조건을 유지할 수 있다.

      ⇒ 이 방식은 간단하면서도 성능적으로 문제가 되지 않게 동시성 이슈를 해결해주기 때문에 이 방법으로 결정.

    - MySQL의 SELECT FOR UPDATE를 활용한 비관적 락 혹은 낙관적 락을 사용

      → 아직 존재하지 않는 row에 대해서는 mysql의 select for update가 잠금을 진행하지 않는다. 낙관적 락 또한 아직 존재하지 않는 row에 대해서는 version등을 관리할 수 없어서 불가능하다.

      → 가입 과정을 가입 예약 , 가입 완료 두 단계로 나누면 비관적 락과 낙관적 락 방식을 사용할 수 있다.

      예를 들면 다음과 같은 방식이다.

        - 비관적 락
            1. 동시에 두 사람이 'a'라는 아이디로 가입하면 회원 테이블에 'a'라는 아이디에 레코드 두 개가 가입 예약 상태로 생긴다.
            2. 가입 예약 상태를 바꾸기 위하여 'a'라는 아이디를 select for update로 조회했더니 레코드 2개가 나온다. 자신이 생성했던 레코드 1개를 가입 완료로 바꾸고 나머지 한 개의 요청은 삭제한다. 
                다른 요청도 마찬가지로 가입완료로 바꾸기 위하여 'a'라는 아이디로 select for update를 한다. 근데 이 예약 중인 row는 앞 요청에 의해서 삭제되고 없으므로 이 요청은 가입 실패하게 된다.
        - 낙관적 락

            1. 동시에 두 사람이 'a'라는 아이디로 가입하면 회원 테이블에 'a'라는 아이디에 레코드 두개가 가입 예약 상태로 생긴다.

            2. 한 요청이 가입 완료 상태로 바꾸기 위하여 'a'라는 아이디로 select를 한다. 결과가 1개가 아니라 2개이므로 2개의 레코드를 모두 삭제하고 가입에 실패한다. 뒤 요청은 'a'라는 아이디로 select했더니 가입 대기 레코드가 아무것도 없어서 가입에 실패한다.

    - LOCK TABLE WRITE으로 테이블을 잠그기

      가능한 방법이지만 테이블 전체를 잠궈서 다른 트랜잭션은 읽지도 쓰지도 못하게하는 방법이기 때문에 회원 테이블에 작업하는 모든 세션들이 기다려야 해서 성능상 좋지 않다.

    - Redis나 MySQL 네임드락을 이용하여 분산 락을 구현하기
        1. Redis. 이용

           회원가입하는 요청들이 Redis에서 key를 생성하면서 lock을 얻어야지 가능하도록 한다. 이 경우 문제를 해결할 수 있지만, Redis 서버를 따로 운영해주어야 한다는 부담이 있다.

        2. Mysql 네임드락 이용

           네임드 락을 이용하여 회원 가입에 대해 모두 ”join[유저 아이디]”이라는 이름을 가진 같은 lock을 얻게 한다. 이렇게하면 서로 같은 아이디로 가입하는 유저들만 락이 걸리므로 쉽게 구현할 수 있다. 하지만 추가적으로 구현해줘야 할 부분이 있어서 구현하기 번거롭다.
            
           ---

           [https://techblog.woowahan.com/2631/](https://techblog.woowahan.com/2631/)

### 일반적인 아이디 중복체크를 할 때와 아이디 중복으로 인하여 가입에 실패했을 때 어떤 상태코드를 내보내야 할까?
    
    일반적인 중복체크 상황에서는 중복이든 아니든 클라이언트의 요청 자체는 문제가 없고 요청대로 체크를 잘 한 상황이므로 OK 상태코드를 보낸다.
    
    아이디 중복으로 가입이 실패하는 상황은 클라이언트의 요청이 실패한 상황이고 이 문제가 서버 문제가 아니고 클라이언트의 문제이므로 일단 4xx번대에서 가장 들어맞는 상황인 conflict를 내려보낸다.

### partial response 형태의 api를 구축해야할까?
    
    이 API의 형태를 구축하는 이유는 네트워크 대역폭을 아끼기 위해서다. 즉 성능을 높 히기 위해서다.
    
    하지만 이 형태를 도입하려면 구현해주어야할 것이 많다. q=name%3djiwoo, ~ 이런 식으로 쿼리도 바꾸어야 하고 그것을 서버쪽에서 파싱해야 한다. 또한 response도 동적으로 변경되야 한다.
    
    아직 성능적인 문제가 확실하지 않은 상황에서 오버 엔지니어링을 하는 것이 아닌가 싶다.
    
    물론 실제로 문제가 될 때가서 바꾸려면 많은 시간이 들 것이다. 하지만 지금은 실무를 하는 상황이 아니기 때문에 일단은 이 형태로 구현하지 않고 문제가 있다면 그 문제를 직접 느껴보는 것이 좋을 것 같다.
    
    또한 아이디 중복체크할 때 유저 찾는 상황 외에는 유저 정보는 /mypage에서 찾을 때로 경로가 다르기 때문에 아이디 중복 체크용 response는 partial하게 구성할 수 있다.
    
    보통은 응답을 일관되게 내보내고 응답이 달라져야 하는 경우는 API EndPoint를 다르게 구성하는 것 같다. 위와 같은 형태는 정말로 네트워크 대역폭을 아끼는게 매우 중요할 때거나 혹은 옛날 방식일 수도 있겠다. - by derek
    
### Util 클래스 이름을 Util 클래스로 통일하는 이유는?
    
    빈과 유틸 클래스를 구분하기 위함도 있고 통일성을 가져가기 위함도 있다.
    
    또한 Utils가 아니라 Util인 이유는 자바에서 제공하는 StringUtils같은 것과 구분하기 위함이다.
    
### Util 클래스를 스태틱만 갖게 만드는 거랑 빈(싱글톤)으로 만드는 거랑 무슨 차이가 있을까?
    
    큰 차이는 없다. 빈으로 만들게 되면 초기에 프로젝트를 실행하면서 빈들을 모두 로딩할 때 시간이 약간 길어지는 정도? 굳이 다른 빈들을 주입받아야 하는 상황이 아니라면 굳이 빈으로 만들 필요가 없다.
    
### 유저를 찾았을 때 유저가 존재하지 않는다면 상태코드로 무엇을 내려야 할까?
    
    일단 두가지 방식이 있는데, OK를 내려보내고 찾은 유저는 null로 주거나 NOT_FOUND를 내려보낼 수 있다.
    
    NOT_FOUND를 내려주는게 좋다. 왜냐하면 PATCH /users/{userId}를 했는데 유저가 없는 경우에는 무조건 NOT_FOUND를 내려주어야 하기 때문이다.
    
    따라서 찾고자 하는 유저가 없는 상황에서 NOT_FOUND를 공통적으로 내려보내면 프론트엔드 쪽에서 일관되게 처리를 할 수 있기 때문에 좋다.
    
### 목록을 찾았을 때 목록에 아무 데이터가 존재하지 않는다면 상태코드로 무엇을 내려야 할까?
    
    200 OK와 빈 어레이를 내려보낸다. 왜냐하면 목록은 비어 있더라도 그 자체가 의미가 있기 때문이다. 페이징 관점에서 보면 하나의 목록은 페이지 정보, 토탈 개수 등등을 묶어 하나의 페이지 데이터로 만들고 이 경우 0개인 것 또한 의미있는 리소스이다.
    
    또 단건과 복수건을 다르게 보는 이유는 단건은 null이 반환되어 그에 관한 처리를 해야하지만  복수건은 빈 어레이로써 null처리를 해줄 필요 없이 프론트엔드 쪽에서 비지 않았을 때와 마찬가지로 동일하게 처리할 수 있기 때문이다.
    
    화면을 떠올려보면 간단하다. 유저의 정보를 찾았는데 유저가 없다면 아무것도 보여줄게 없고 프론트엔드 쪽에서 그에 따른 처리를 해야 한다. 그러나 목록을 찾았는데 아무것도 존재하지 않는다면 그냥 빈 목록을 보여줄 것이다.
    
    프론트 엔드 입장에서 전자는 원하는 결과를 얻지 못했다고 볼 수 있고 후자는 원하는 결과를 얻었다고 볼 수 있다.
    
    ---
    
    > 단건은 리소스에 대해 존재한다 존재하지 않는다로 판별하는 생각에 기초하고 있고요. 복수건은 몇개의 앨리먼트로 구성되어 있는지에 대한 생각에 기초하고 있는 것 같습니다(일반적인?)
    > 
    > 
    > 기본적으로 null pointer exception을 회피하는 사상 안에서 논리를 구성한 것으로 보입니다! 목록은 목록 자체로 의미있기에 npe가 발생할 일이 없기 때문에요. - by derek 멘토님
    > 
    
    > 또 페이징 목록 관점에서 보면 ,목록 자체가 리소스라고 판별한다고 볼 수 있습니다!
    > 
    > 
    > 예를들면, 페이징 조회할 때 리소스 목록 데이터 외에 페이지 정보, 토탈 개수 등등을 묶어 하나의 페이지 데이터로 만드는 것이고 개수가 0개인 것 또한 의미있는 리소스이며 not found라고 보지 않는다는 관점입니다.
    >


### 권한 체크를 필터로 할 것인가 인터셉터로 할 것인가?
    
    필터는 Handler 관련 정보를 얻을 수 없다.
    
    제외 경로를 지정하기 위해서는 추가적인 구현 코드가 필요하다.
    
    들어올 때와 나갈 때가 하나의 메소드 안에 들어 있어서 SRP 원칙이 지켜지지 않을 수 있다.
    
    예외가 발생했을 때 controlleradvice에서 처리해줄 수 없다. 
    
### 회원가입하는 순간에 DB에 중복체크를 맞기고 튀어나오는 DuplicateKeyException을 일일이 분리할 것인가?
    
    어차피 사용자가 아이디를 입력하고 중복체크를 할 테고 이메일 전화번호도 마찬가지다. 그런데 회원가입 버튼을 최종적으로 눌러서 join()을 탈 때 중복체크를 해줘야 할까?
    
    그렇다. 왜냐하면 사용자가 중복체크를 한 후 회원가입을 누르기까지 텀이 꽤 길다. 그 사이에 다른 사용자가 동일한 아이디로 가입할 수 있기 때문이다.
    
    따라서 join()에서 중복체크를 해줌으로써 아이디나 이메일 전화번호 등의 중복을 걸러낸다.
    
    그런데 그 중복체크도 통과하고 정말고 DB에 INSERT하는 순간에 동일한 아이디나 이메일 등으로 가입하는 상황이 있을 수 있다. 이것은 DB에 Unique속성에 맡긴다. 대신에 이러한 상황은 희박하기 때문에 이후에 DuplicateKeyExcepion에 에러메시지를 일일이 분석해서 DuplicateLoginIdException, DuplicatedEmailExcepion등으로 분리하는 것은 오버엔지니어링이다. 또 DB 오류메시지에 너무 의존하기 때문에 추후 버전이 올라가면서 버전이 바뀌게 되면 로직이 망가지게 된다.
    
### 세션 로그인 방식을 사용중인데 세션에 로그인 유저를 저장하는 부분은 컨트롤러에 놓을까 서비스에 놓을까?
    컨트롤러 단에 놓는다. 왜냐하면 세션은 웹과 관련된 부분이다. service는 최대한 웹과 관련된 부분에 의존하지 않고 순수하게 유지하는 것이 좋다. 
    왜냐하면 service는 모든 코드에서 가장 중요한 부분이며 이 모듈을 기준으로 다른 모듈들이 플러그인 방식으로 끼워지는 형태여야 한다. 
    웹과 관련된 부분이 없어지거나 다른 것으로 변경될 수도 있고, 프로토콜이 Http가 쓰이지 않는 상황에서도 service는 변함없이 재사용할 수 있어야 한다.

    컨트롤러 단에 놓으면 나중에 JWT 방식 같이 새로운 로그인 방식이 도입됐을 때 어떻게 해야할까 싶지만 그 때는 그에 맞는 새로운 컨트롤러(JWTLoginController)를 추가해서 등록해주면 된다. 
    오히려 컨트롤러 단을 의존하고 있는 다른 계층이 없기 때문에 LoginController와 같이 인터페이스를 추가할 필요도 없고 깔끔한 것 같기도 하다.
    (Service에서 했다면 LoginService라는 인터페이스를 필수로 두어야 기존 코드에 변경 없이 새로운 방식의 로그인 서비스가 도입 가능하다.

    하나 걸리는 점은 Session 같은 경우는 웹과 관련된 부분이기 때문에 웹 컨트롤러에서 처리했지만 JWT에서 토큰을 생성하거나 그런 부분도 컨트롤러에서 담당해야할지 모르겠다.

### Redis host나 password 등등 key 관리는 어떻게 하면 좋을까?
    
    일단 application.yml 같은 곳에서 관리하면 절대 안된다. 깃헙에 올라가게 되면 노출된 서버로 DDOS 공격을 받아서 요금 폭탄이 나올 수도 있고 password를 이용하여 데이터를 털어갈 수도 있다.
    
    이 때 jar 파일을 실행할 때 환경변수로 넘겨주는 방법도 괜찮지만 매번 그 때마다 값을 정확하게 입력해주고 관리해야하는 작업이 부담이 있다.
    
    따라서 AWS나 네이버 클라우드 같은데서는 Key Management System, Key Management Service 등을 제공한다. 이것을 사용하면 좋다.
    
### 테스트용으로 신뢰가 떨어지는 embedded-redis를 쓰는 것이 괜찮을까?
    
    일반적으로는 이렇게 개인 개발자가 만드는 라이브러리는 실제 프로덕션에 사용하지 않는다. 왜냐하면 안전성이 떨어지기 때문에 버그가 생길 여지도 많고 패치가 잘못되면 망하기도 하고 그렇기 때문이다.
    
    실무에서는 최대한 공인된 곳(Apache 등)에서 제공하는 라이브러리를 쓰려고 노력하며 최근에 업데이트가 자주 일어나고 있는지, Github 스타 수 등을 파악해서 사용한다.
    
    하지만 embedded-redis가 실제로 프로덕션으로 배포도는 것이 아니라 테스트용으로만 사용되는 것이기 때문에 그렇게 부담갖지 않고 사용해도 될 것 같다. 어차피 실제 DB를 이용한 테스트 또한 진행될 것이기 때문이다.