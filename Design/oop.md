# 객체지향 프로그래밍

### 객체란 무엇인가? ★

    클래스의 복제본

    세상에 존재하는 모든 유일무이한 사물
    
    클래스가 분류에 대한 개념이라면 객체는 실체라고 할 수 있다.
    
    클래스와 객체를 구분하는 방법은 생물은 나이, 사물은 제조일자를 물어보면 된다.
    
    사람은 몇살인가? 김연아는 몇살인가? 티비는 언제 제조됐는가? 이 LGTV(LM-255 모델명)은 언제 제조됐는가?
    
    사람은 클래스고 김연아는 객체다.
    
    ---
    
    김종민, 스프링 입문을 위한 자바 객체 지향의 원리와 이해, 초판 4쇄, 위키북스, 82p, 2020

### 객체 지향 프로그래밍이란 무엇인가?
    상태와 행위를 갖는 독립적인 객체들을 메시지를 통해 협력시키며 하나의 프로그램을 완성시켜 나가는 프로그래밍 방법론.
    이름 때문에 객체에 주목하기 쉽지만 객체 지향 프로그래밍에서 객체보다 중요한 것은 메시지이다.

### 어떤 배경에서 객체 지향 프로그래밍이 등장했을까?

    컴퓨터는 초창기 주로 과학실험이나 미사일 발사실험과 같은 모의 실험을 목적으로 사용되었다.
    
    이 시절의 과학자들은 모의 실험을 위해 실제 세계와 유사한 가상 세계를 컴퓨터 속에 구현하고자 노력하였으며 이러한 노력은 객체지향이론을 탄생시켰다.
    
    객체지향이론의 기본 개념은 ‘실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다’라는 것이다.
    
    실제 사물의 속성과 기능을 분석한 다음, 데이터(변수)와 함수로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상세계를 구현하고
    이 가상세계에서 모의실험을 함으로써 많은 시간과 비용을 절약할 수 있었다.


### 객체지향은 어떻게 인기가 많아졌을까?

    초기에는 절차적 언어에 밀려 객체지향 언어는 인기가 없었다.
    
    프로그램의 규모가 커지고 사용자들의 요구가 빠르게 변화해가는 상황을 절차적 언어로는 극복하기 어렵다는 한계를 느끼고  
    객체지향언어를 이용한 개발방벌론이 대안으로 떠오르게 되면서 입지를 넓혀갔다.
    
    이 후 인터넷의 발전과 함께 자바가 발표되면서 객체지향언어가 대세로 자리잡게 됐다.
    
    객체지향 이론의 탄생은 현실세계 모델링에 대한 요구로 이루어졌으나,   
    코드의 재사용성이 높고 유지보수가 용이하다는 장점이 객체지향 언어를 널리 퍼지게 만들어주었다.

### 왜 객체 지향 프로그래밍을 해야 하는가?

    좋은 코드를 짜기 위해서

    - 좋은 코드란 무엇인가?

    제대로 실행되며, 변경에 유연하고, 이해하기 쉬운 코드.

    - 제대로 실행

      기존 절차적 프로그래밍은 프로그래밍이 거대해질수록 제대로 실행되는 코드를 만들기도 어려워진다. 객체지향 프로그래밍은 프로그램을 객체 단위로 구조화 시켜줌으로써 프로그램을 작성하기 용이하게 해준다.

    - 변경에 유연

      객체 지향 프로그래밍에서 각 객체는 자신의 상태를 은닉한다.

      그 말은 한 객체가 다른 객체의 상태에 접근할 수 없다는 의미이고, 이는 객체의 상태를 변경하더라도 그 변경의 여파가 그 객체 내로 제한된다.

      또한 객체들은 메시지를 이용해서 협력하는데 그 메시지를 받은 객체가 어떤식으로 그 메시지를 처리하는지는 알지 못한다.

      따라서 한 객체가 자신이 받은 메시지를 처리하는 방식(메소드)을 바꾸었을 때 그 메시지의 인터페이스가 그대로라면, 그 메시지를 전달하는 객체는 변경에 영향 받지 않는다.

      이러한 이유들로 객체 지향 프로그래밍은 변경에 유연함을 가져다 준다.

    - 이해하기 쉬운

      연관된 변수와 메소드를 묶어 객체를 이용해 현실세계와 비슷하게 모델링할 수 있다. 이는 인간의 직관과 위배되지 않아 이해하기 쉽다.

      예를 들어 극장에서 티켓을 판매하는 프로그램이 있다고 가정할 때,

      절차적 프로그래밍은 극장이 손님의 가방을 뒤져서 돈을 가져간다면,

      객체 지향 프로그래밍은 극장이 손님에게 돈을 달라는 메세지를 보내고 메시지를 전달받은 손님은 돈을 주게된다.

      하지만 극장과 같이 무생물이 어떤 ‘행위’를 가진다는 점은 우리의 직관과 약간 위배되기는 한다.

### 객체 지향 프로그래밍의 단점은 무엇이 있을까?
    멀티쓰레드 프로그래밍이 함수형 프로그래밍에 비해 까다롭다.
        
    객체 지향 프로그래밍은 기본적으로 객체의 상태를 여러 메소드가 건드리게 된다.  
    쓰레드들이 동시에 메소드를 실행하는 과정에서 이러한 상태 변경이 문제를 야기하기 쉽다.  
    객체 지향 프로그래밍은 이러한 문제를 막기 위해서 추가적인 작업이 필요하다.  
    함수형 프로그래밍은 기본적으로 불변객체나 순수함수를 기반으로 작동하기 때문에 상대적으로 이러한 문제로부터 자유롭다.

### 자바는 객체 지향 언어라는데 어떤 특징이 있어야 객체지향 언어라고 할 수 있을까?

    객체지향언어는 기존의 프로그래밍 언어와 다른 전혀 새로운 것이 아니라,   
    기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 보다 발전된 형태의 것이다.

    어떤 언어가 추상화, 캡슐화, 상속, 다형성  등의 기능을 지원한다면
    그 지원하는 정도만큼 객체 지향 언어에 가깝다라고 할 수 있다.

### 객체 지향에는 클래스가 꼭 필요할까?

    객체 지향 언어에서는 메시지를 주고 받을 객체가 필요하다.

    객체는 클래스를 통해서 만들 수 있다.

    그러나 이름이 클래스가 아니더라도 상태와 행위를 묶을 수 있는 어떠한 것이 있다면 그것이 어떤 것이든 상관 없다.
        
    - 자바스크립트는 클래스가 없는데 어떻게 객체 지향을 구현할 수 있을까?

        프로토타입이라는 것을 통해서 구현할 수 있다.


### 객체의 null 체크가 중요한 이유는?
    
    null인 객체에 메소드를 호출하며 NullPointerException이 발생하기 때문에
    
### 런타임 다형성은 내부적으로 어떻게 구현되어 있을까?
    
    A라는 클래스를 상속한 B라는 클래스를 A 타입을 가진 변수에 할당하고,
    오버라이딩한 메소드 eat()를 호출했다고 가정하자.
    
    컴파일이 되고 난 후에는 바이트 코드에 A의 eat()를 사용한다고 나와 있다.
    
    어떻게 jvm은 이 명령을 보고 B의 eat()를 호출할 수 있을까?
    
    JVM은 클래스를 로딩할 때 이 클래스의 Class 객체를 만들고 이 클래스가 상속하고 있는 모든 클래스의 메소드가 적혀 있는 주소를 갖고 있는 vtable이란 것을 만든다.
    
    이 때 어떤 메소드가 오버라이딩 되어 있으면 부모의 메소드 이름으로도 자식의 메소드 주소가 참조되도록 vtable에 적는다.
    
    예를 들면 이런 식이다.
    
    vtable
    
    Name  Address
    
    A.eat()    211    // 자식의 메소드 주소를 가르킴
    
    B.eat()    211
    
    JVM은 invokevirtual을 호출할 때마다 어떤 주소에 있는 메소드를 호출해야하는지 vtable을 참조한다. 
    이 때 메소드의 이름을 통해서 그 메소드의 주소를 얻게 되는데 위처럼 부모 메소드의 이름이 자식 메소드의 주소를 가르키고 있으므로 자식 메소드가 실행되는 것이다.
    
     
    
    vtable이랑 엮어서 좀 더 이해 필요 
    
    ---
    
    [https://dzone.com/articles/how-does-jvm-handle-polymorphism-method-overloadin](https://dzone.com/articles/how-does-jvm-handle-polymorphism-method-overloadin)
    
    - vtable이란?
### Overriding vs Overloading
    - Overriding은 상위 클래스에 존재하는 메서드를 하위 크래스에 맞게 재정의하는 것을 의미합니다. 이 때 메서드 이름과 파라미터의 수, 리턴타입은 동일해야 합니다.
    - Overloading은 두 메서드가 같은 이름을 가지고 있으나, 파라미터 수나 자료형이 다른 경우를 Overloading이라고 합니다.
### 왜 Overriding할 때 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 못할까?
    
    자식 클래스를 조상클래스 타입 변수에 할당했다고 해보자.
    
    조상클래스에 정의된대로 public인 method를 호출했는데, 
    자식 클래스에서는 private으로 오버라이딩 되어있으면 제대로 작동하지 않을 것이다.
### overloading은 어떻게 가능한 걸까? 왜 C언어는 overloading을 하지 못할까?
    
    오버로딩은 자바의 컴파일러가 지원해주는 것이고 C언어는 컴파일러가 지원해주지 않기 때문이다.
    
    자바는 컴파일러가 심볼 테이블에 메서드 심볼을 저장할 때 메서드 이름 뿐만이 아니라 리턴 타입과 파리미터 정보까지 포함해서 저장한다. 
    반면에 C언어의 컴파일러는 단순히 메서드 이름만으로 심볼을 저장한다.
    
    따라서 C언어에서 같은 이름의 메서드가 2개 이상 있다면 링킹 과정에서 어떤 메서드를 링킹해야하는지 링커가 알 수가 없다. 
    
    ---
    
    [https://stackoverflow.com/questions/1314613/is-there-a-reason-that-c99-doesnt-support-function-overloading](https://stackoverflow.com/questions/1314613/is-there-a-reason-that-c99-doesnt-support-function-overloading)
    
    [https://www.geeksforgeeks.org/does-c-support-function-overloading/](https://www.geeksforgeeks.org/does-c-support-function-overloading/)   


### 객체 지향의 4대 특성에 대해서 설명해주세요
    - 캡슐화(Capsulation)
    - 상속(Extends)
        
        상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 추가할 수 있다는 말이다.
        
        즉 ‘확장’의 의미이지 말 그대로 ‘상속’의 의미는 아니다.
        
        이 때 ‘하위 클래스는 상위 클래스다’ 라는 말을 반드시 만족해야 상속 관계라고 할 수 있다. 
        
        예를 들면 ‘포유류는 동물이다’, ‘고래는 포유류다’는 상속 관계이지만
        ’아버지는 할아버지다’는 말이 안되므로 아버지와 할아버지는 객체 지향에서 말하는 상속 관계가 아니다.
        
        영어로 하면 is a kind of 관계를 만족해야 한다고 볼 수 있다.
        
        고래 is a kind of 동물 → 고래는 동물의 한 분류다.
        
    - 추상화
        
        추상화란 목적에 맞게 관심 있는 특성만을 추출해서 실제 사물을 단순하게 묘사하는 것이다. 
        
        자바는 이런 추상화를 class라는 키워드를 통해서 제공하는 것이다.
        
        이렇게 class라는 키워드를 통해 추상화해서 표현하는 것을 모델링이라고 한다
        
    - 다형성
        poly = 많은 morphism = 형태의 뜻을 가진 그리스어이다.
        
        즉 많은 형태라는 뜻으로, 구체적으로 하나의 메소드가 다양한 방식으로 작동하는 것을 의미한다.
        
        자바에서 다형성은 컴파일 타임 다형성과 런타임 다형성으로 나누어지는데 
        이 둘은 오버로딩과 오버라이딩으로 구현할 수 있다.
        
        ---
        
        [https://www.javatpoint.com/runtime-polymorphism-in-java](https://www.javatpoint.com/runtime-polymorphism-in-java)
        
        [https://en.wikipedia.org/wiki/Polymorphism_(computer_science)](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
        
        - 컴파일 타임 다형성과 런타임 다형성의 차이는?
            
            컴파일 타임에 어떤 메소드가 쓰일지 결정된다면 컴파일 타임 다형성이고
            
            런타임에 어떤 메소드가 쓰일지 결정된다면 런타임 다형성이다.
            
            예를 들어 A라는 클래스가 있고 eat()와 eat(String name)의 형태로 메소드가 오버로딩되어 있다고 가정하자.
            A라는 클래스를 인스턴스화 한후 eat(”h”)라는 메소드를 호출하자.
            
            이 때 컴파일을 하고 나면 바이트 코드는 정확히 eat(String name)을 호출하도록 된다.
            
            즉 컴파일 타임에 어떤 메소드가 쓰일지 결정되는 것 이다.
            
            다음은 A라는 클래스를 상속한 B라는 클래스를 A 타입을 가진 변수에 할당하고,
            오버라이딩한 메소드 eat()를 호출했다고 가정하자.
            
            컴파일이 되고 난 후에는 바이트 코드에 A의 eat()를 사용한다고 나와 있다.
            
            따라서 컴파일 이후에도 여전히 어떤 메소드가 쓰일지 결정된 상황이 아니다.
            
            런타임이 되어서야 jvm이 eat()메소드를 실행할 때 B의 eat()가 적혀 있는 주소로 가서 메소드를 실행하게 될 것이다.
            
            ---
            
            [https://www.javatpoint.com/runtime-polymorphism-in-java](https://www.javatpoint.com/runtime-polymorphism-in-java)
            
            [https://en.wikipedia.org/wiki/Polymorphism_(computer_science)](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
            
            [https://dzone.com/articles/how-does-jvm-handle-polymorphism-method-overloadin](https://dzone.com/articles/how-does-jvm-handle-polymorphism-method-overloadin)
        
    ---
    
    김종민, 스프링 입문을 위한 자바 객체 지향의 원리와 이해, 초판 4쇄, 위키북스, [, 107-117, 89, 2020


### 객체 지향의 5대 원칙(SOLID)에 대해서 설명해주세요
    - SRP(Single Resposibility Principle)

        SRP는 하나의 클래스는 하나의 책임을 가져야 하고, 하나의 책임은 하나의 클래스가 가져야 한다는 원칙이다.

        이 때 책임의 크기는 ‘변경의 단위’이다. 변경을 요구하는 것은 사람이다. 

        예를 들어 ‘결제하기’라는 책임은 너무 크다. 변경이 일어날 때 단순히 ‘결제하기’라는 기능에 변경이 일어나지 않는다. 더 작은 단위인 ‘결제 수단의 변경’, ‘할인 방식의 변경’ 등이 나타난다. 이런 것들이 하나하나가 책임이다.

        그리고 사람들은 ‘할인 방식을 변경해주세요.’ 또는 ‘결제 수단을 변경해주세요.’ 라고 요구한다.

        - SRP를 지키지 않으면 무슨 일이 벌어질까?
            1. 의존성 문제
                
                한 클래스가 서로 다른 책임을 가진 두 메소드를 갖고 있다고 해보자.
                
                예를 들어 Employee라는 클래스가 있을 때 reportHours(), calculateSalary()등의 메소드를 갖고 있다. 이 때 reportHours()는 인사팀에서 기능을 정의하고 사용하며 COO 보고를 위해 사용한다. calculateSalary()는 회계팀에서 기능을 정의하며 CFO 보고를 위해 사용한다.
                
                두 Actor(책임)을 한 클래스가 담당하고 있으니 SRP를 지키지 않는 셈이다.
                
                이 때 두 메소드가 초과 근무를 제외한 업무 시간을 계산하는 방식인 regularHours()라는 메소드를 같이 사용한다고 해보자. 만약 인사팀에 의해서 이 메소드의 구현 사항을 변경하고 싶은 욕구가 들어왔을 때 회계팀과 관련된 메소드인 caclulateSalary()까지 영향을 받게 된다. 
                
                즉 서로 공유하는 메소드나 변수가 있을 때 다른 한 쪽의 공유 메소드 변경에 의하여 예상치 못한 결과가 나타나게 되는 상황이다.
                
            2. 병합 문제
                
                서로 다른 책임을 갖고 있는 클래스는 동시에 다른 팀에서 수정이 될 수 있다. 이는 병합을 해야하며 병합은 문제를 발생시키기 쉽다.
                
            3. 산탄총 수술
                
                하나의 기능을 변경해야 하는데 여러 클래스를 건드려야 한다. 얼마나 많은 클래스가 연관되어 있는지 파악이 안되어 끝을 알 수 없다는 점이다. 
                
                마치 산탄총에 맞은 환자의 몸에 박힌 총알을 빼내는 의사의 상황과 같다. 수술도 고되지만 모든 환부를 찾아야 하는 집중력과 긴장감이 개발자를 힘들게 한다.

        - SRP를 잘 지켜서 설계하기 위해서는 어떻게 해야할까?
    
            먼저 처음 설계할 때 단일 책임 원칙을 고려하는 습관을 들인다. 
    
            설계는 한번에 좋은 설계가 나오기 쉽지 않기 때문에 리팩토링을 꾸준히 하면서 다음 과정을 거친다.
    
            만약 어떤 클래스가 여러가지 원인에 의해서 변경된다면 그 클래스는 SRP가 지켜지지 않은 것이다.
    
            이 때는 여러 책임을 갖고 있는 클래스를 Extract class를 통해 분리하고 만약 분리된 두 클래스가 유사한 책임을 갖고 있다면 그 부분만 Extract SuperClass해서 분리하는 방식으로 SRP를 유도한다.
    
            만약 어떤 기능의 변경이 여러 클래스에 변경을 유발한다면 이는 하나의 책임은 하나의 클래스가 가져야 한다는 SRP를 위반하고 있는 것이다.
    
            각 클래스에서 이 기능에 대한 메소드와 필드를 추출해서 하나의 클래스로 모아주어야 한다.

        ---

        https://zdnet.co.kr/view/?no=00000039135552

    - OCP(Open-Cloesd Principle)

        확장에는 열려 있고 변경에는 닫혀 있어야 한다는 의미다.

        중간에 인터페이스를 두어서 어떤 기능에 추가되어도 기존 코드에는 변경이 없게끔 하는 것을 말한다.

        예를 들어 어떤 운전자가 있고 이 운전자가 마티즈라는 차를 갖고 있다고 해보자.

        이 운전자는 소나타라는 차를 추가하고 싶은데(확장) 기존 마티즈와 운전 방식이 다르기 때문에 쉽사리 추가하기가 어렵다.

        왜냐하면 마티즈는 수동 방식, 소나타는 자동 방식이기 때문에 소나타로 자동차를 바꾸면 운전자의 운전 방식에 변경이 일어나기 때문이다.

        이 때 만약 중간에 버튼 조작 인터페이스가 있어서 수동이든 자동이든 버튼 하나로 조작할 수 있다면
        운전자는 자동차를 추가하기 쉬울 것이고 자동차를 추가하더라도 운전자의 운전 방식에 변경이 일어나지 않을 것이다.

        즉 확장에는 열려 있고 변경에는 닫혀 있게 된다.

        이러한 방식이 프로그래밍에서도 동일하게 작용한다.

        - OCP를 잘 지켜서 설계하기 위해서는 어떻게 해야할까?
            
            인터페이스가 추가된다는 것은 프로그램의 복잡도가 증가한다는 의미이다.
            
            따라서 무조건 인터페이스를 추가하려고 하지 말고 상황에 맞게 추가해야 한다.
            

        ---

        [https://zdnet.co.kr/view/?no=00000039134727](https://zdnet.co.kr/view/?no=00000039134727)

        최범균, 객체 지향 프로그래밍 입문, 인프런, 다형성과 추상화 파트

    - LSP(Liskov Substitution Principle)

        상위 타입을 구현한 하위 타입은 interface의 규약대로 구현해야 한다.

        자동차 인터페이스를 구현한 클래스가 액셀을 밟았을 때 뒤로가게끔 구현하면 안된다는 의미이다.
    
        어떤 사람이 차를 타고 액셀을 밟았는데 뒤로 가면 사고가 날 것이다.
    
        마찬가지로 프로그램도 프로그램이 예상대로 동작하지 않기 때문에 문제가 생길 것이다.
    
        ---
    
        김영한, 스프링 핵심 원리 - 기본편, 인프런, SOLID 파트

    - ISP(Interface Segregation Principle)
        많은 기능을 하는 클래스가 있을 때 각 기능들을 여러 인터페이스로 분리하는 것을 말한다.

        이렇게 함으로써 이 클래스를 이용하는 다른 클래스들이 자신과 상관없는 기능에 변화에 대해 재컴파일 할 필요 없게 만들어준다. 
        (각 클래스는 자신이 원하는 기능을 갖고 있는 인터페이스만 같이 배포됨으로써 영향을 받지 않는다.)

        일반적으로 이런 경우에 SRP를 사용하여 클래스를 분리하지만 그렇게 하기 어려운 경우 에 ISP를 사용한다.

        예를 들어 클래스가 ‘이체’라는 기능을 담당할 때 이 기능은

        1. 트랜잭션을 시작한다.
        2. 상대의 계좌 존재여부를 확인한다.
        3. 고객의 계좌에 원하는 금액을 출금한다.
        4. 상대의 계좌에 입금한다.
        5. 트랜잭션을 마친다.

        의 절차를 갖고 각각은 사실 분해될 수 있는 기능들이지만 이 기능들이 합쳐져서 ‘이체’라는 기능을 담당하게 되고 나누기 애매하다.

        이럴 때 ISP를 사용한다. 

        ---

        [Robert C. Martin,*The Interface Segregation Principle*, C++ Report, June 1996](https://docs.google.com/a/cleancoder.com/viewer?a=v&pid=explorer&chrome=true&srcid=0BwhCYaYDn8EgOTViYjJhYzMtMzYxMC00MzFjLWJjMzYtOGJiMDc5N2JkYmJi&hl=en)

        백명석 클린 코더스 강의 14.3

    - DIP(Dependency inversion Principle)
        
        DIP란 상위 수준의 모듈이 하위 수준의 모듈의 의존하지 않고 하위 수준의 모듈이 하쉬 수준의 모듈에 의존하게 하게해서
        고수준 모듈의 변경은 최소화하고 저수준 모듈의 변경의 유연함을 높혀주는 것을 말합니다.
        
        고수준 모듈은 상위 수준의 정책을 구현하는 클래스 또는 패키지라고 할 수 있고 
        저수준 모듈은 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능을 실제로 구현하는 클래스 또는 패키지라 할 수 있습니다.
        
        예를 들어 ‘이미지 저장’이라는 기능을 제공하는 고수준 모듈이 있습니다. 이 모듈이 저수준 모듈에 의존하고 있기 때문에 고수준 모듈의 코드에는 Astorage.save()와 같은 코드가 들어있다고 하겠습니다.
        
        만약 저장하는 저장소가 Astorage에서 Bstoreage로 바뀌게 된다면 고수준 모듈의 코드는 Astorage.save()에서 Bstorage.save()로 바뀌어야 합니다.
        
        고수준의 정책이 바뀌지 않았는데 저수준의 구현 변경으로 인해 고수준 모듈의 코드가 변경이 되는 것입니다.
        
        이 때 고수준 모듈의 관점에서 FileService라는 추상타입을 정의하고 저수준 모듈이 이 FileService라는 고수준 모듈에 의존하게 만들면 DIP를 지키게 됩니다.
        
        이 때 코드는 fileService.save()로 추상화된 형태가 될 것이고 Astorage에서 Bstorage로 바뀌어도 이 코드는 변화가 없을 것입니다.
        
        ---
        
        최범균, 객체 지향 프로그래밍 입문, 인프런, DIP파트 
        
        - 왜 고수준 모듈이 저수준 모듈에 의존하는 것이 좋지 않은 설계일까?
            
            저수준의 모듈은 자주 변경될 수 있기 때문에 이러한 설계는 좋지 않습니다.
            자주 바뀌지 않는 고수준 모듈에 저수준 모듈이 의존하는 것이 더 좋은 설계라고 할 수 있습니다. 
            
            단순하게 생각해서 한달의 고수준 모듈이 1번 변경되고 저수준 모듈이 10번 변경된다고 가정할 때, 
            고수준 모듈이 저수준 모듈에 의존하면 고수준 모듈은 총 11번 변경되고 저수준 모듈은 10번 변경될 것입니다. 
            하지만 저수준 모듈이 고수준 모듈에 의존하게 되면 고수준 모듈은 1번 변경될 것이고, 저수준 모듈은 11번 변경될 것입니다.



