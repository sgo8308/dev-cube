<details>
<summary>데몬이란?</summary>
<br>
데몬(Deamon)은  부팅 때 자동으로 켜져 백그라운드에서 계속 실행되는 프로세스를 의미한다.

계속 실행된다는 것이 핵심으로 단순히 백그라운드에서 실행됐다가 종료되는 프로세스를 데몬이라고 부르지는 않는다.

꺼지지 않고 실시간으로 클라이언트와 통신을 계속 해야하는 서버 프로세스들이 주로 데몬이라고 불린다.

---

[https://mamu2830.blogspot.com/2020/04/blog-post_18.html#:~:text=3.-,데몬 서비스란%3F,-그리고 차이점](https://mamu2830.blogspot.com/2020/04/blog-post_18.html#:~:text=3.-,%EB%8D%B0%EB%AA%AC%20%EC%84%9C%EB%B9%84%EC%8A%A4%EB%9E%80%3F,-%EA%B7%B8%EB%A6%AC%EA%B3%A0%20%EC%B0%A8%EC%9D%B4%EC%A0%90)
</details>
    
<details>
<summary>Copy와 소프트 링크 하드 링크의 차이는?</summary>
<br>
Copy는 말 그대로 파일을 복사하는 것이다. 10GB의 파일을 복사하면 디스크 저장 공간은 20GB를 차지하게 될 것이다.

하드 링크는 INode를 공유하는 것이다. 따라서 새로운 하드 링크가 생겨도 디스크 저장 공간은 그대로 유지된다.
특이한 점은 하드 링크를 하게 되면 원본이 삭제되더라도 Inode는 남아 있어서 하드 링크된 파일에 여전히 접근 가능하다.

소프트 링크는 윈도우의 바로가기와 같다. 원본이 사라지면 소프트 링크도 제 기능을 할 수 없다.
특이한 점은 소프트 링크를 위한 INode가 새로 생긴다는 점이다. 그러나 이 INode는 주소 데이터로 소프트 링크 대상 INode의 주소 공간으로 리다이렉트하게 된다.

---

컴퓨터 공학 전공자 따라잡기, 시스템 프로그래밍, ch3 9-10
</details>

<details>
<summary>POSIX란?</summary>
<br>
여러 유닉스 관련 OS들의 API와 ABI에 대한 하나의 표준적인 인터페이스.

POSIX를 지키는 각 운영체제에서 만들어진 프로그램은 서로의 운영체제에서 호환된다.

이 때 API는 시스템 콜 등 여러 프로그래밍 용 인터페이스를 말하고

ABI는 내부적으로 어떤 식으로 메모리에 할당할지(가상 메모리에서 주소를 0번부터 시작할지 끝번부터 시작할지), 함수의 인자들을 어떤 레지스터에 넣을 것인지, 함수 실행 방식, 라이브러리 링크 방식등등의 구현 세부 사항에 대한 인터페이스를 말한다.

API가 소스 코드에서 사용된다면 ABI는 바이너리에서 호환이 가능하다는 점이 다르다.

API가 호환이 되면 소스 코드를 안 고쳐도 되고, ABI가 같으면 실행 파일을 재컴파일 할 필요 없이 실행이 가능하다.

리눅스에서 만든 프로그램이 윈도우에서 실행되지 않는 가장 큰 이유는 ABI가 달라서이고, 그 다음이 시스템 콜 라이브러리가 다르기 때문이다.

---

컴퓨터 공학 전공자 따라잡기, 시스템 프로그래밍, ch04-2
</details>

<details>
<summary>시스템 콜 중 fork와 exec의 차이는?</summary>
<br>
리눅스에서 프로세스는 부모 프로세스로부터 복사되어 만들어진다.

최초의 부모 프로세스를 init이다.

부모 프로세스에서 자식 프로세스를 복사할 때 사용하는 시스템 콜이 fork이다. fork를 할 경우 메모리에 부모 프로세스와 동일한 프로세스가 생성된다.

이 때 부모 프로세스와 동일한 프로세스를 계속 사용한다면 그대로 진행하면 되고, 새로운 프로그램의 프로세스를 만들고 싶다면 exec 시스템 콜을 사용하면 된다.

exec 시스템 콜을 사용하면 현재 프로세스의 code, data, bss 부분을 인자로 받은 실행 파일로 덮어 씌운다. 새로운 프로그램은 이런 식으로 실행되는 것이다.
</details>    

<details>
<summary>좀비 프로세스와 고아 프로세스란?</summary>
<br>
부모 프로세스가 자식 프로세스보다 먼저 죽을 경우 자식 프로세스는 고아 프로세스가 된다.

리눅스에서는 프로세스가 죽으면 해당 프로세스의 부모 프로세스에서 죽은 프로세스의 상태를 점검하는 작업이 이루어진다.

이를 위해서 메모리에는 프로세스 ID, 정상적으로 죽었는지, 에러가 일어났는지와 같은 프로세스 상태 정보가 자식 프로세스의 사망 이후에도 남아 있다.

부모 프로세스에서는 wait이라는 시스템 콜을 통해서 자식 프로세스가 죽을 때까지 기다린 후 위에서 언급한 상태를 점검해야 한다. 그렇게 해야 메모리에서 이 정보가 사라지게 된다.

일반적으로 부모 프로세스가 먼저 죽게 되면 고아 프로세스의 부모 프로세스는 init 프로세스가 되고 wait을 호출하여 메모리에서 관련 정보를 제거해준다.

그러나 자식 프로세스가 먼저 죽었는데 부모 프로세스에서 wait을 호출하지 않은 경우 죽은 프로세스의 정보가 메모리에 계속 남아 있게 되는데 이것을 좀비 프로세스라고 한다.

---

[https://codetravel.tistory.com/31](https://codetravel.tistory.com/31)

</details>    
<details>
<summary>copy on write란?</summary>
<br>
write할 때 copy를 진행한다는 뜻이다.

일반적으로 32bit 리눅스는 각 프로세스가 4GB의 공간을 가지고 있으며 그 중 1GB의 영역은 모두 커널의 코드를 갖고 있다.

새로운 프로세스를 생성할 때 4GB를 새로 생성한다면 매우 시간이 많이 걸릴 것이며 똑같은 커널 코드가 복사되는 것도 비효율적일 것이다.

따라서 리눅스에서는 프로세스를 생성할 때 fork로 프로세스를 생성 후 새로운 프로세스의 페이지 테이블은 부모 프로세스의 페이지 테이블과 동일한 상태를 갖게 한다.

이렇게 할 경우 프로세스는 2개가 생성되었지만 동일한 페이지를 사용하므로 메모리를 아낄 수 있으며 프로세스 생성 또한 매우 빨라진다.

이 후 write 작업이 생길 경우 그 때 가서야 해당하는 페이지를 실제로 복사하게 되는데, 이것을 copy on write라고 한다.

커널 영역의 코드의 경우 각 프로세스 개별적으로 write 할 일이 없기 때문에 copy가 일어나지 않고 모든 프로세스가 동일한 커널 영역의 코드를 공유하게 된다.
</details>
<details>
<summary>시그널이란?</summary>
<br>
시그널이란 커널 또는 프로세스에서 다른 프로세스로 보내는 신호를 의미한다.

각각의 프로세스는 이 신호를 받았을 때 어떤 처리를 할지가 이미 정의되어 있는 상태이며 이 코드는 커널 내부에 기록되어 있다.

이를테면 SIG_KILL이란 시그널을 받을 경우 프로세스는 종료가 된다.

각각의 PCB에는 시그널 관련 정보 데이터가 담겨 있다.

프로세스는 수시로 사용자 모드와 커널 모드를 왔다갔다 하는데, 보통 커널 모드에서 사용자 모드로 가기 전에 프로세스에 들어와 있는 시그널에 대한 처리를 진행하고 사용자 모드로 전환하게 된다.

---

컴퓨터 공학 전공자 따라잡기, 시스템 프로그래밍, ch07-1
</details>    